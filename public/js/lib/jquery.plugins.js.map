{"version":3,"sources":["sortable.js","tagging.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACprBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"jquery.plugins.js","sourcesContent":["/* ===================================================\r\n *  jquery-sortable.js v0.9.13\r\n *  http://johnny.github.com/jquery-sortable/\r\n * ===================================================\r\n *  Copyright (c) 2012 Jonas von Andrian\r\n *  All rights reserved.\r\n *\r\n *  Redistribution and use in source and binary forms, with or without\r\n *  modification, are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n *  * The name of the author may not be used to endorse or promote products\r\n *    derived from this software without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n *  DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n * ========================================================== */\r\n\r\n\r\n!function ( $, window, pluginName, undefined){\r\n  var containerDefaults = {\r\n    // If true, items can be dragged from this container\r\n    drag: true,\r\n    // If true, items can be droped onto this container\r\n    drop: true,\r\n    // Exclude items from being draggable, if the\r\n    // selector matches the item\r\n    exclude: \"\",\r\n    // If true, search for nested containers within an item.If you nest containers,\r\n    // either the original selector with which you call the plugin must only match the top containers,\r\n    // or you need to specify a group (see the bootstrap nav example)\r\n    nested: true,\r\n    // If true, the items are assumed to be arranged vertically\r\n    vertical: true\r\n  }, // end container defaults\r\n  groupDefaults = {\r\n    // This is executed after the placeholder has been moved.\r\n    // $closestItemOrContainer contains the closest item, the placeholder\r\n    // has been put at or the closest empty Container, the placeholder has\r\n    // been appended to.\r\n    afterMove: function ($placeholder, container, $closestItemOrContainer) {\r\n    },\r\n    // The exact css path between the container and its items, e.g. \"> tbody\"\r\n    containerPath: \"\",\r\n    // The css selector of the containers\r\n    containerSelector: \"ol, ul\",\r\n    // Distance the mouse has to travel to start dragging\r\n    distance: 0,\r\n    // Time in milliseconds after mousedown until dragging should start.\r\n    // This option can be used to prevent unwanted drags when clicking on an element.\r\n    delay: 0,\r\n    // The css selector of the drag handle\r\n    handle: \"\",\r\n    // The exact css path between the item and its subcontainers.\r\n    // It should only match the immediate items of a container.\r\n    // No item of a subcontainer should be matched. E.g. for ol>div>li the itemPath is \"> div\"\r\n    itemPath: \"\",\r\n    // The css selector of the items\r\n    itemSelector: \"li\",\r\n    // The class given to \"body\" while an item is being dragged\r\n    bodyClass: \"dragging\",\r\n    // The class giving to an item while being dragged\r\n    draggedClass: \"dragged\",\r\n    // Check if the dragged item may be inside the container.\r\n    // Use with care, since the search for a valid container entails a depth first search\r\n    // and may be quite expensive.\r\n    isValidTarget: function ($item, container) {\r\n      return true\r\n    },\r\n    // Executed before onDrop if placeholder is detached.\r\n    // This happens if pullPlaceholder is set to false and the drop occurs outside a container.\r\n    onCancel: function ($item, container, _super, event) {\r\n    },\r\n    // Executed at the beginning of a mouse move event.\r\n    // The Placeholder has not been moved yet.\r\n    onDrag: function ($item, position, _super, event) {\r\n      $item.css(position)\r\n    },\r\n    // Called after the drag has been started,\r\n    // that is the mouse button is being held down and\r\n    // the mouse is moving.\r\n    // The container is the closest initialized container.\r\n    // Therefore it might not be the container, that actually contains the item.\r\n    onDragStart: function ($item, container, _super, event) {\r\n      $item.css({\r\n        height: $item.outerHeight(),\r\n        width: $item.outerWidth()\r\n      })\r\n      $item.addClass(container.group.options.draggedClass)\r\n      $(\"body\").addClass(container.group.options.bodyClass)\r\n    },\r\n    // Called when the mouse button is being released\r\n    onDrop: function ($item, container, _super, event) {\r\n      $item.removeClass(container.group.options.draggedClass).removeAttr(\"style\")\r\n      $(\"body\").removeClass(container.group.options.bodyClass)\r\n    },\r\n    // Called on mousedown. If falsy value is returned, the dragging will not start.\r\n    // Ignore if element clicked is input, select or textarea\r\n    onMousedown: function ($item, _super, event) {\r\n      if (!event.target.nodeName.match(/^(input|select|textarea)$/i)) {\r\n        event.preventDefault()\r\n        return true\r\n      }\r\n    },\r\n    // The class of the placeholder (must match placeholder option markup)\r\n    placeholderClass: \"placeholder\",\r\n    // Template for the placeholder. Can be any valid jQuery input\r\n    // e.g. a string, a DOM element.\r\n    // The placeholder must have the class \"placeholder\"\r\n    placeholder: '<li class=\"placeholder\"></li>',\r\n    // If true, the position of the placeholder is calculated on every mousemove.\r\n    // If false, it is only calculated when the mouse is above a container.\r\n    pullPlaceholder: true,\r\n    // Specifies serialization of the container group.\r\n    // The pair $parent/$children is either container/items or item/subcontainers.\r\n    serialize: function ($parent, $children, parentIsContainer) {\r\n      var result = $.extend({}, $parent.data())\r\n\r\n      if(parentIsContainer)\r\n        return [$children]\r\n      else if ($children[0]){\r\n        result.children = $children\r\n      }\r\n\r\n      delete result.subContainers\r\n      delete result.sortable\r\n\r\n      return result\r\n    },\r\n    // Set tolerance while dragging. Positive values decrease sensitivity,\r\n    // negative values increase it.\r\n    tolerance: 0\r\n  }, // end group defaults\r\n  containerGroups = {},\r\n  groupCounter = 0,\r\n  emptyBox = {\r\n    left: 0,\r\n    top: 0,\r\n    bottom: 0,\r\n    right:0\r\n  },\r\n  eventNames = {\r\n    start: \"touchstart.sortable mousedown.sortable\",\r\n    drop: \"touchend.sortable touchcancel.sortable mouseup.sortable\",\r\n    drag: \"touchmove.sortable mousemove.sortable\",\r\n    scroll: \"scroll.sortable\"\r\n  },\r\n  subContainerKey = \"subContainers\"\r\n\r\n  /*\r\n   * a is Array [left, right, top, bottom]\r\n   * b is array [left, top]\r\n   */\r\n  function d(a,b) {\r\n    var x = Math.max(0, a[0] - b[0], b[0] - a[1]),\r\n    y = Math.max(0, a[2] - b[1], b[1] - a[3])\r\n    return x+y;\r\n  }\r\n\r\n  function setDimensions(array, dimensions, tolerance, useOffset) {\r\n    var i = array.length,\r\n    offsetMethod = useOffset ? \"offset\" : \"position\"\r\n    tolerance = tolerance || 0\r\n\r\n    while(i--){\r\n      var el = array[i].el ? array[i].el : $(array[i]),\r\n      // use fitting method\r\n      pos = el[offsetMethod]()\r\n      pos.left += parseInt(el.css('margin-left'), 10)\r\n      pos.top += parseInt(el.css('margin-top'),10)\r\n      dimensions[i] = [\r\n        pos.left - tolerance,\r\n        pos.left + el.outerWidth() + tolerance,\r\n        pos.top - tolerance,\r\n        pos.top + el.outerHeight() + tolerance\r\n      ]\r\n    }\r\n  }\r\n\r\n  function getRelativePosition(pointer, element) {\r\n    var offset = element.offset()\r\n    return {\r\n      left: pointer.left - offset.left,\r\n      top: pointer.top - offset.top\r\n    }\r\n  }\r\n\r\n  function sortByDistanceDesc(dimensions, pointer, lastPointer) {\r\n    pointer = [pointer.left, pointer.top]\r\n    lastPointer = lastPointer && [lastPointer.left, lastPointer.top]\r\n\r\n    var dim,\r\n    i = dimensions.length,\r\n    distances = []\r\n\r\n    while(i--){\r\n      dim = dimensions[i]\r\n      distances[i] = [i,d(dim,pointer), lastPointer && d(dim, lastPointer)]\r\n    }\r\n    distances = distances.sort(function  (a,b) {\r\n      return b[1] - a[1] || b[2] - a[2] || b[0] - a[0]\r\n    })\r\n\r\n    // last entry is the closest\r\n    return distances\r\n  }\r\n\r\n  function ContainerGroup(options) {\r\n    this.options = $.extend({}, groupDefaults, options)\r\n    this.containers = []\r\n\r\n    if(!this.options.rootGroup){\r\n      this.scrollProxy = $.proxy(this.scroll, this)\r\n      this.dragProxy = $.proxy(this.drag, this)\r\n      this.dropProxy = $.proxy(this.drop, this)\r\n      this.placeholder = $(this.options.placeholder)\r\n\r\n      if(!options.isValidTarget)\r\n        this.options.isValidTarget = undefined\r\n    }\r\n  }\r\n\r\n  ContainerGroup.get = function  (options) {\r\n    if(!containerGroups[options.group]) {\r\n      if(options.group === undefined)\r\n        options.group = groupCounter ++\r\n\r\n      containerGroups[options.group] = new ContainerGroup(options)\r\n    }\r\n\r\n    return containerGroups[options.group]\r\n  }\r\n\r\n  ContainerGroup.prototype = {\r\n    dragInit: function  (e, itemContainer) {\r\n      this.$document = $(itemContainer.el[0].ownerDocument)\r\n\r\n      // get item to drag\r\n      var closestItem = $(e.target).closest(this.options.itemSelector);\r\n      // using the length of this item, prevents the plugin from being started if there is no handle being clicked on.\r\n      // this may also be helpful in instantiating multidrag.\r\n      if (closestItem.length) {\r\n        this.item = closestItem;\r\n        this.itemContainer = itemContainer;\r\n        if (this.item.is(this.options.exclude) || !this.options.onMousedown(this.item, groupDefaults.onMousedown, e)) {\r\n            return;\r\n        }\r\n        this.setPointer(e);\r\n        this.toggleListeners('on');\r\n        this.setupDelayTimer();\r\n        this.dragInitDone = true;\r\n      }\r\n    },\r\n    drag: function  (e) {\r\n      if(!this.dragging){\r\n        if(!this.distanceMet(e) || !this.delayMet)\r\n          return\r\n\r\n        this.options.onDragStart(this.item, this.itemContainer, groupDefaults.onDragStart, e)\r\n        this.item.before(this.placeholder)\r\n        this.dragging = true\r\n      }\r\n\r\n      this.setPointer(e)\r\n      // place item under the cursor\r\n      this.options.onDrag(this.item,\r\n                          getRelativePosition(this.pointer, this.item.offsetParent()),\r\n                          groupDefaults.onDrag,\r\n                          e)\r\n\r\n      var p = this.getPointer(e),\r\n      box = this.sameResultBox,\r\n      t = this.options.tolerance\r\n\r\n      if(!box || box.top - t > p.top || box.bottom + t < p.top || box.left - t > p.left || box.right + t < p.left)\r\n        if(!this.searchValidTarget()){\r\n          this.placeholder.detach()\r\n          this.lastAppendedItem = undefined\r\n        }\r\n    },\r\n    drop: function  (e) {\r\n      this.toggleListeners('off')\r\n\r\n      this.dragInitDone = false\r\n\r\n      if(this.dragging){\r\n        // processing Drop, check if placeholder is detached\r\n        if(this.placeholder.closest(\"html\")[0]){\r\n          this.placeholder.before(this.item).detach()\r\n        } else {\r\n          this.options.onCancel(this.item, this.itemContainer, groupDefaults.onCancel, e)\r\n        }\r\n        this.options.onDrop(this.item, this.getContainer(this.item), groupDefaults.onDrop, e)\r\n\r\n        // cleanup\r\n        this.clearDimensions()\r\n        this.clearOffsetParent()\r\n        this.lastAppendedItem = this.sameResultBox = undefined\r\n        this.dragging = false\r\n      }\r\n    },\r\n    searchValidTarget: function  (pointer, lastPointer) {\r\n      if(!pointer){\r\n        pointer = this.relativePointer || this.pointer\r\n        lastPointer = this.lastRelativePointer || this.lastPointer\r\n      }\r\n\r\n      var distances = sortByDistanceDesc(this.getContainerDimensions(),\r\n                                         pointer,\r\n                                         lastPointer),\r\n      i = distances.length\r\n\r\n      while(i--){\r\n        var index = distances[i][0],\r\n        distance = distances[i][1]\r\n\r\n        if(!distance || this.options.pullPlaceholder){\r\n          var container = this.containers[index]\r\n          if(!container.disabled){\r\n            if(!this.$getOffsetParent()){\r\n              var offsetParent = container.getItemOffsetParent()\r\n              pointer = getRelativePosition(pointer, offsetParent)\r\n              lastPointer = getRelativePosition(lastPointer, offsetParent)\r\n            }\r\n            if(container.searchValidTarget(pointer, lastPointer))\r\n              return true\r\n          }\r\n        }\r\n      }\r\n      if(this.sameResultBox)\r\n        this.sameResultBox = undefined\r\n    },\r\n    movePlaceholder: function  (container, item, method, sameResultBox) {\r\n      var lastAppendedItem = this.lastAppendedItem\r\n      if(!sameResultBox && lastAppendedItem && lastAppendedItem[0] === item[0])\r\n        return;\r\n\r\n      item[method](this.placeholder)\r\n      this.lastAppendedItem = item\r\n      this.sameResultBox = sameResultBox\r\n      this.options.afterMove(this.placeholder, container, item)\r\n    },\r\n    getContainerDimensions: function  () {\r\n      if(!this.containerDimensions)\r\n        setDimensions(this.containers, this.containerDimensions = [], this.options.tolerance, !this.$getOffsetParent())\r\n      return this.containerDimensions\r\n    },\r\n    getContainer: function  (element) {\r\n      return element.closest(this.options.containerSelector).data(pluginName)\r\n    },\r\n    $getOffsetParent: function  () {\r\n      if(this.offsetParent === undefined){\r\n        var i = this.containers.length - 1,\r\n        offsetParent = this.containers[i].getItemOffsetParent()\r\n\r\n        if(!this.options.rootGroup){\r\n          while(i--){\r\n            if(offsetParent[0] != this.containers[i].getItemOffsetParent()[0]){\r\n              // If every container has the same offset parent,\r\n              // use position() which is relative to this parent,\r\n              // otherwise use offset()\r\n              // compare #setDimensions\r\n              offsetParent = false\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        this.offsetParent = offsetParent\r\n      }\r\n      return this.offsetParent\r\n    },\r\n    setPointer: function (e) {\r\n      var pointer = this.getPointer(e)\r\n\r\n      if(this.$getOffsetParent()){\r\n        var relativePointer = getRelativePosition(pointer, this.$getOffsetParent())\r\n        this.lastRelativePointer = this.relativePointer\r\n        this.relativePointer = relativePointer\r\n      }\r\n\r\n      this.lastPointer = this.pointer\r\n      this.pointer = pointer\r\n    },\r\n    distanceMet: function (e) {\r\n      var currentPointer = this.getPointer(e)\r\n      return (Math.max(\r\n        Math.abs(this.pointer.left - currentPointer.left),\r\n        Math.abs(this.pointer.top - currentPointer.top)\r\n      ) >= this.options.distance)\r\n    },\r\n    getPointer: function(e) {\r\n      var o = e.originalEvent || e.originalEvent.touches && e.originalEvent.touches[0]\r\n      return {\r\n        left: e.pageX || o.pageX,\r\n        top: e.pageY || o.pageY\r\n      }\r\n    },\r\n    setupDelayTimer: function () {\r\n      var that = this\r\n      this.delayMet = !this.options.delay\r\n\r\n      // init delay timer if needed\r\n      if (!this.delayMet) {\r\n        clearTimeout(this._mouseDelayTimer);\r\n        this._mouseDelayTimer = setTimeout(function() {\r\n          that.delayMet = true\r\n        }, this.options.delay)\r\n      }\r\n    },\r\n    scroll: function  (e) {\r\n      this.clearDimensions()\r\n      this.clearOffsetParent() // TODO is this needed?\r\n    },\r\n    toggleListeners: function (method) {\r\n      var that = this,\r\n      events = ['drag','drop','scroll']\r\n\r\n      $.each(events,function  (i,event) {\r\n        that.$document[method](eventNames[event], that[event + 'Proxy'])\r\n      })\r\n    },\r\n    clearOffsetParent: function () {\r\n      this.offsetParent = undefined\r\n    },\r\n    // Recursively clear container and item dimensions\r\n    clearDimensions: function  () {\r\n      this.traverse(function(object){\r\n        object._clearDimensions()\r\n      })\r\n    },\r\n    traverse: function(callback) {\r\n      callback(this)\r\n      var i = this.containers.length\r\n      while(i--){\r\n        this.containers[i].traverse(callback)\r\n      }\r\n    },\r\n    _clearDimensions: function(){\r\n      this.containerDimensions = undefined\r\n    },\r\n    _destroy: function () {\r\n      containerGroups[this.options.group] = undefined\r\n    }\r\n  }\r\n\r\n  function Container(element, options) {\r\n    this.el = element\r\n    this.options = $.extend( {}, containerDefaults, options)\r\n\r\n    this.group = ContainerGroup.get(this.options)\r\n    this.rootGroup = this.options.rootGroup || this.group\r\n    this.handle = this.rootGroup.options.handle || this.rootGroup.options.itemSelector\r\n\r\n    var itemPath = this.rootGroup.options.itemPath\r\n    this.target = itemPath ? this.el.find(itemPath) : this.el\r\n\r\n    this.target.on(eventNames.start, this.handle, $.proxy(this.dragInit, this))\r\n\r\n    if(this.options.drop)\r\n      this.group.containers.push(this)\r\n  }\r\n\r\n  Container.prototype = {\r\n    dragInit: function  (e) {\r\n      var rootGroup = this.rootGroup\r\n\r\n      if( !this.disabled &&\r\n          !rootGroup.dragInitDone &&\r\n          this.options.drag &&\r\n          this.isValidDrag(e)) {\r\n        rootGroup.dragInit(e, this)\r\n      }\r\n    },\r\n    isValidDrag: function(e) {\r\n      return e.which == 1 ||\r\n        e.type == \"touchstart\" && e.originalEvent.touches.length == 1\r\n    },\r\n    searchValidTarget: function  (pointer, lastPointer) {\r\n      var distances = sortByDistanceDesc(this.getItemDimensions(),\r\n                                         pointer,\r\n                                         lastPointer),\r\n      i = distances.length,\r\n      rootGroup = this.rootGroup,\r\n      validTarget = !rootGroup.options.isValidTarget ||\r\n        rootGroup.options.isValidTarget(rootGroup.item, this)\r\n\r\n      if(!i && validTarget){\r\n        rootGroup.movePlaceholder(this, this.target, \"append\")\r\n        return true\r\n      } else\r\n        while(i--){\r\n          var index = distances[i][0],\r\n          distance = distances[i][1]\r\n          if(!distance && this.hasChildGroup(index)){\r\n            var found = this.getContainerGroup(index).searchValidTarget(pointer, lastPointer)\r\n            if(found)\r\n              return true\r\n          }\r\n          else if(validTarget){\r\n            this.movePlaceholder(index, pointer)\r\n            return true\r\n          }\r\n        }\r\n    },\r\n    movePlaceholder: function  (index, pointer) {\r\n      var item = $(this.items[index]),\r\n      dim = this.itemDimensions[index],\r\n      method = \"after\",\r\n      width = item.outerWidth(),\r\n      height = item.outerHeight(),\r\n      offset = item.offset(),\r\n      sameResultBox = {\r\n        left: offset.left,\r\n        right: offset.left + width,\r\n        top: offset.top,\r\n        bottom: offset.top + height\r\n      }\r\n      if(this.options.vertical){\r\n        var yCenter = (dim[2] + dim[3]) / 2,\r\n        inUpperHalf = pointer.top <= yCenter\r\n        if(inUpperHalf){\r\n          method = \"before\"\r\n          sameResultBox.bottom -= height / 2\r\n        } else\r\n          sameResultBox.top += height / 2\r\n      } else {\r\n        var xCenter = (dim[0] + dim[1]) / 2,\r\n        inLeftHalf = pointer.left <= xCenter\r\n        if(inLeftHalf){\r\n          method = \"before\"\r\n          sameResultBox.right -= width / 2\r\n        } else\r\n          sameResultBox.left += width / 2\r\n      }\r\n      if(this.hasChildGroup(index))\r\n        sameResultBox = emptyBox\r\n      this.rootGroup.movePlaceholder(this, item, method, sameResultBox)\r\n    },\r\n    getItemDimensions: function  () {\r\n      if(!this.itemDimensions){\r\n        this.items = this.$getChildren(this.el, \"item\").filter(\r\n          \":not(.\" + this.group.options.placeholderClass + \", .\" + this.group.options.draggedClass + \")\"\r\n        ).get()\r\n        setDimensions(this.items, this.itemDimensions = [], this.options.tolerance)\r\n      }\r\n      return this.itemDimensions\r\n    },\r\n    getItemOffsetParent: function  () {\r\n      var offsetParent,\r\n      el = this.el\r\n      // Since el might be empty we have to check el itself and\r\n      // can not do something like el.children().first().offsetParent()\r\n      if(el.css(\"position\") === \"relative\" || el.css(\"position\") === \"absolute\"  || el.css(\"position\") === \"fixed\")\r\n        offsetParent = el\r\n      else\r\n        offsetParent = el.offsetParent()\r\n      return offsetParent\r\n    },\r\n    hasChildGroup: function (index) {\r\n      return this.options.nested && this.getContainerGroup(index)\r\n    },\r\n    getContainerGroup: function  (index) {\r\n      var childGroup = $.data(this.items[index], subContainerKey)\r\n      if( childGroup === undefined){\r\n        var childContainers = this.$getChildren(this.items[index], \"container\")\r\n        childGroup = false\r\n\r\n        if(childContainers[0]){\r\n          var options = $.extend({}, this.options, {\r\n            rootGroup: this.rootGroup,\r\n            group: groupCounter ++\r\n          })\r\n          childGroup = childContainers[pluginName](options).data(pluginName).group\r\n        }\r\n        $.data(this.items[index], subContainerKey, childGroup)\r\n      }\r\n      return childGroup\r\n    },\r\n    $getChildren: function (parent, type) {\r\n      var options = this.rootGroup.options,\r\n      path = options[type + \"Path\"],\r\n      selector = options[type + \"Selector\"]\r\n\r\n      parent = $(parent)\r\n      if(path)\r\n        parent = parent.find(path)\r\n\r\n      return parent.children(selector)\r\n    },\r\n    _serialize: function (parent, isContainer) {\r\n      var that = this,\r\n      childType = isContainer ? \"item\" : \"container\",\r\n\r\n      children = this.$getChildren(parent, childType).not(this.options.exclude).map(function () {\r\n        return that._serialize($(this), !isContainer)\r\n      }).get()\r\n\r\n      return this.rootGroup.options.serialize(parent, children, isContainer)\r\n    },\r\n    traverse: function(callback) {\r\n      $.each(this.items || [], function(item){\r\n        var group = $.data(this, subContainerKey)\r\n        if(group)\r\n          group.traverse(callback)\r\n      });\r\n\r\n      callback(this)\r\n    },\r\n    _clearDimensions: function  () {\r\n      this.itemDimensions = undefined\r\n    },\r\n    _destroy: function() {\r\n      var that = this;\r\n\r\n      this.target.off(eventNames.start, this.handle);\r\n      this.el.removeData(pluginName)\r\n\r\n      if(this.options.drop)\r\n        this.group.containers = $.grep(this.group.containers, function(val){\r\n          return val != that\r\n        })\r\n\r\n      $.each(this.items || [], function(){\r\n        $.removeData(this, subContainerKey)\r\n      })\r\n    }\r\n  }\r\n\r\n  var API = {\r\n    enable: function() {\r\n      this.traverse(function(object){\r\n        object.disabled = false\r\n      })\r\n    },\r\n    disable: function (){\r\n      this.traverse(function(object){\r\n        object.disabled = true\r\n      })\r\n    },\r\n    serialize: function () {\r\n      return this._serialize(this.el, true)\r\n    },\r\n    refresh: function() {\r\n      this.traverse(function(object){\r\n        object._clearDimensions()\r\n      })\r\n    },\r\n    destroy: function () {\r\n      this.traverse(function(object){\r\n        object._destroy();\r\n      })\r\n    }\r\n  }\r\n\r\n  $.extend(Container.prototype, API)\r\n\r\n  /**\r\n   * jQuery API\r\n   *\r\n   * Parameters are\r\n   *   either options on init\r\n   *   or a method name followed by arguments to pass to the method\r\n   */\r\n  $.fn[pluginName] = function(methodOrOptions) {\r\n    var args = Array.prototype.slice.call(arguments, 1)\r\n\r\n    return this.map(function(){\r\n      var $t = $(this),\r\n      object = $t.data(pluginName)\r\n\r\n      if(object && API[methodOrOptions])\r\n        return API[methodOrOptions].apply(object, args) || this\r\n      else if(!object && (methodOrOptions === undefined ||\r\n                          typeof methodOrOptions === \"object\"))\r\n        $t.data(pluginName, new Container($t, methodOrOptions))\r\n\r\n      return this\r\n    });\r\n  };\r\n\r\n}(jQuery, window, 'sortable');","// taggingJS v1.3.3\r\n//    2014-10-24\r\n\r\n// Copyright (c) 2014 Fabrizio Fallico\r\n\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in\r\n//  all copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n(function( $, window, document, undefined ) {\r\n\r\n    /**\r\n     * taggingJS Constructor\r\n     *\r\n     * @param obj elem     DOM object of tag box\r\n     * @param obj options  Custom JS options\r\n     */\r\n    var Tagging = function( elem, options ) {\r\n        this.elem    = elem;          // The tag box\r\n        this.$elem   = $( elem );     // jQuerify tag box\r\n        this.options = options;       // JS custom options\r\n        this.tags = [];               // Here we store all tags\r\n        // this.$type_zone = void 0;  // The tag box's input zone\r\n    };\r\n\r\n    /**\r\n     * taggingJS Prototype\r\n     */\r\n    Tagging.prototype = {\r\n\r\n\r\n        // All special Keys\r\n        keys: {\r\n            // Special keys to add a tag\r\n            add: {\r\n                comma:    188,\r\n                enter:    13,\r\n                spacebar: 32,\r\n            },\r\n\r\n            // Special keys to remove last tag\r\n            remove: {\r\n                del: 46,\r\n                backspace: 8,\r\n            }\r\n        },\r\n\r\n        // Default options value\r\n        defaults: {\r\n            \"case-sensitive\": false,                        // True to allow differences between lowercase and uppercase\r\n            \"close-char\": \"&times;\",                        // Single Tag close char\r\n            \"close-class\": \"tag-i\",                         // Single Tag close class\r\n            \"edit-on-delete\": true,                         // True to edit tag that has just been removed from tag box\r\n            \"forbidden-chars\": [ \".\", \"_\", \"?\" ],           // Array of forbidden characters\r\n            \"forbidden-chars-callback\": window.alert,       // Function to call when there is a forbidden chars\r\n            \"forbidden-chars-text\": \"Forbidden character:\", // Basic text passed to forbidden-chars callback\r\n            \"forbidden-words\": [],                          // Array of forbidden words\r\n            \"forbidden-words-callback\": window.alert,       // Function to call when there is a forbidden words\r\n            \"forbidden-words-text\": \"Forbidden word:\",      // Basic text passed to forbidden-words callback\r\n            \"no-backspace\": false,                          // Backspace key remove last tag, true to avoid that\r\n            \"no-comma\": false,                              // Comma \",\" key add a new tag, true to avoid that\r\n            \"no-del\": false,                                // Delete key remove last tag, true to avoid that\r\n            \"no-duplicate\": true,                           // No duplicate in tag box\r\n            \"no-duplicate-callback\": window.alert,          // Function to call when there is a duplicate tag\r\n            \"no-duplicate-text\": \"Duplicate tag:\",          // Basic text passed to no-duplicate callback\r\n            \"no-enter\": false,                              // Enter key add a new tag, true to avoid that\r\n            \"no-spacebar\": false,                           // Spacebar key add a new tag by default, true to avoid that\r\n            \"pre-tags-separator\": \", \",                     // By default, you must put new tags using a new line\r\n            \"tag-box-class\": \"tagging\",                     // Class of the tag box\r\n            \"tag-char\": \"#\",                                // Single Tag char\r\n            \"tag-class\": \"tag\",                             // Single Tag class\r\n            \"tags-input-name\": \"tag\",                       // Name to use as name=\"\" in single tags (by default tag[])\r\n            \"tag-on-blur\": true,                            // Add the current tag if user clicks away from type-zone\r\n            \"type-zone-class\": \"type-zone\",                 // Class of the type-zone\r\n        },\r\n\r\n        /**\r\n         * Add a tag\r\n         *\r\n         * @param string            text  Text to add as tag, if null we get the content of tag box type_zone.\r\n         * @return boolean|funtion        true if OK; false if NO; function with some config error.\r\n         */\r\n        add: function( text ) {\r\n\r\n            // console.log( 'add' );\r\n\r\n            var $tag, l, self,\r\n                index, forbidden_words,\r\n                callback_f, callback_t;\r\n\r\n            // Caching this\r\n            self = this;\r\n\r\n            // If text is an array, call add on each element\r\n            if ( $.isArray( text ) ) {\r\n                // Adding text present on type_zone as tag on first call\r\n                return $.each( text, function() {\r\n                    self.add( this + \"\" );\r\n                });\r\n            }\r\n\r\n            // Forbidden Words shortcut\r\n            forbidden_words = self.config[ \"forbidden-words\" ];\r\n\r\n            // If no text is passed, take it as text of $type_zone and then empty it\r\n            if ( ! text ) {\r\n                text = self.valInput();\r\n                self.emptyInput();\r\n            }\r\n\r\n            // If text is empty too, then go out\r\n            if ( ! text || ! text.length ) {\r\n                return false;\r\n            }\r\n\r\n            // If case-sensitive is true, write everything in lowercase\r\n            if ( ! self.config[ \"case-sensitive\" ] ) {\r\n                text = text.toLowerCase();\r\n            }\r\n\r\n            // Checking if text is a Forbidden Word\r\n            l = forbidden_words.length;\r\n            while ( l-- ) {\r\n\r\n                // Looking for a forbidden words\r\n                index = text.indexOf( forbidden_words[ l ] );\r\n\r\n                // There is a forbidden word\r\n                if ( index >= 0 ) {\r\n\r\n                    // Removing all text and ','\r\n                    self.emptyInput();\r\n\r\n                    // Renaiming\r\n                    callback_f = self.config[ \"forbidden-words-callback\" ];\r\n                    callback_t = self.config[ \"forbidden-words-text\" ];\r\n\r\n                    // Remove as a duplicate\r\n                    return self.throwError( callback_f, callback_t, text );\r\n                }\r\n            }\r\n\r\n            // If no-duplicate is true, check that the text is not already present\r\n            if ( self.config[ \"no-duplicate\" ] ) {\r\n\r\n                // Looking for each text inside tags\r\n                l = self.tags.length;\r\n                while ( l-- ) {\r\n                    if ( self.tags[ l ].pure_text === text ) {\r\n\r\n                        // Removing all text and ','\r\n                        self.emptyInput();\r\n\r\n                        // Renaiming\r\n                        callback_f = self.config[ \"no-duplicate-callback\" ];\r\n                        callback_t = self.config[ \"no-duplicate-text\" ];\r\n\r\n                        // Remove the duplicate\r\n                        return self.throwError( callback_f, callback_t, text );\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Creating a new div for the new tag\r\n            $tag = $( document.createElement( \"div\" ) )\r\n                        .addClass( self.config[ \"tag-class\" ] )\r\n                        .html(  \"<span>\" + self.config[ \"tag-char\" ] + \"</span> \" + text  );\r\n\r\n            // Creating and Appending hidden input\r\n            $( document.createElement( \"input\" ) )\r\n                .attr( \"type\", \"hidden\" )\r\n                // custom input name\r\n                .attr( \"name\", self.config[ \"tags-input-name\" ] + \"[]\" )\r\n                .val( text )\r\n                .appendTo( $tag );\r\n\r\n            // Creating and tag button (with \"x\" to remove tag)\r\n            $( document.createElement( \"a\" ) )\r\n                .attr( \"role\", \"button\" )\r\n                // adding custom class\r\n                .addClass( self.config[ \"close-class\" ] )\r\n                // using custom char\r\n                .html( self.config[ \"close-char\" ] )\r\n                // click addEventListener\r\n                .click(function() {\r\n                    self.remove( $tag );\r\n                })\r\n                // finally append close button to tag element\r\n                .appendTo( $tag );\r\n\r\n            // Adding pure_text and position property to $tag\r\n            $tag.pure_text = text;\r\n\r\n            // Adding to tags the new tag (as jQuery Object)\r\n            self.tags.push( $tag );\r\n\r\n            // Adding tag in the type zone\r\n            self.$type_zone.before( $tag );\r\n\r\n            return true;\r\n        },\r\n\r\n        /**\r\n         * Add a special keys\r\n         *\r\n         * @param  array       arr  Array like ['type', obj], where 'type' is 'add' or 'remove', obj is { key_name: key_num }\r\n         * @return string|obj       Error message or actually 'type'_key (add_key or remove_key).\r\n         */\r\n        addSpecialKeys: function( arr ) {\r\n            // console.log( 'addSpecialKeys' );\r\n\r\n            var self, value, to_add, obj, type;\r\n\r\n            self   = this;\r\n            type   = arr[0];\r\n            obj    = arr[1];\r\n            to_add = {};\r\n\r\n            // If obj is an array, call addSpecialKeys on each element\r\n            if ( $.isArray( obj ) ) {\r\n                return $.each( obj, function() {\r\n                    self.addSpecialKeys( [ type, this ] );\r\n                });\r\n            }\r\n\r\n            // Check if obj is really an object\r\n            // @link http://stackoverflow.com/a/16608045\r\n            if ( ( ! obj ) && ( obj.constructor !== Object ) ) {\r\n                return \"Error -> The second argument is not an Object!\";\r\n            }\r\n\r\n            for ( value in obj ) {\r\n                if ( obj.hasOwnProperty( value ) ) {\r\n                    // @link stackoverflow.com/a/3885844\r\n                    if ( obj[ value ] === +obj[ value ] && obj[ value ] === ( obj[ value ]|0 ) ) {\r\n                        $.extend( to_add, obj );\r\n                    }\r\n                }\r\n            }\r\n\r\n            self.keys[ type ] = $.extend( {}, to_add, self.keys[ type ] );\r\n\r\n            return self.keys[ type ];\r\n        },\r\n\r\n        /**\r\n         * Opposite of init, remove type_zone, all tags and other things.\r\n         *\r\n         * @return boolean\r\n         */\r\n        destroy: function() {\r\n            // console.log( 'destroy' );\r\n\r\n            // Removing the type-zone\r\n            this.$elem.find( \".\" + this.config[ \"type-zone-class\" ] ).remove();\r\n\r\n            // Removing all tags\r\n            this.$elem.find( \".\" + this.config[ \"tag-class\" ] ).remove();\r\n\r\n            // Destroy tag-box parameters\r\n            this.$elem.data( \"tag-box\", null );\r\n\r\n            // Exit with success\r\n            return true;\r\n        },\r\n\r\n        /**\r\n         * Empty tag box's type_zone\r\n         *\r\n         * @return $_obj       The type_zone itself\r\n         */\r\n        emptyInput: function() {\r\n            // console.log( 'emptyInput' );\r\n\r\n            this.focusInput();\r\n\r\n            return this.valInput( \"\" );\r\n        },\r\n\r\n        /**\r\n         * Trigger focus on tag box's input\r\n         *\r\n         * @return $_obj The tag box's input\r\n         */\r\n        focusInput: function() {\r\n            // console.log( 'focusInput' );\r\n\r\n            return this.$type_zone.focus();\r\n        },\r\n\r\n        /**\r\n         * Get Data attributes custom options\r\n         *\r\n         * @return object  Tag-box data attributes options\r\n         */\r\n        getDataOptions: function() {\r\n\r\n            var key, data_option, data_options;\r\n\r\n            // Here we store all data_options\r\n            data_options = {};\r\n\r\n            // For each option\r\n            for ( key in this.defaults ) {\r\n\r\n                // Getting value\r\n                data_option = this.$elem.data( key );\r\n\r\n                // Checking if it is not undefined\r\n                if ( data_option /*!= null*/ ) {\r\n\r\n                    // Saving in data_options object\r\n                    data_options[ key ] = data_option;\r\n\r\n                }\r\n            }\r\n\r\n            return data_options;\r\n        },\r\n\r\n        /**\r\n         * Return all special keys inside an object (without distinction)\r\n         *\r\n         * @return obj\r\n         */\r\n        getSpecialKeys: function() {\r\n            return $.extend( {}, this.keys.add, this.keys.remove );\r\n        },\r\n\r\n        /**\r\n         * Return all special keys inside an object (with distinction)\r\n         *\r\n         * @return obj\r\n         */\r\n        getSpecialKeysD: function() {\r\n            return this.keys;\r\n        },\r\n\r\n        /**\r\n         * Return all tags as string\r\n         *\r\n         * @return array   All tags as member of strings.\r\n         */\r\n        getTags: function() {\r\n            // console.log( 'getTags' );\r\n\r\n            var all_txt_tags, i, l;\r\n\r\n            l = this.tags.length;\r\n            all_txt_tags = [];\r\n\r\n            for ( i = 0; i < l; i += 1 ) {\r\n                all_txt_tags.push( this.tags[ i ].pure_text );\r\n            }\r\n\r\n            return all_txt_tags;\r\n        },\r\n\r\n        /**\r\n         * Return all tags as object\r\n         *\r\n         * @return array   All tags as member of objects.\r\n         */\r\n        getTagsObj: function() {\r\n            // console.log( 'getTagsObj' );\r\n\r\n            return this.tags;\r\n        },\r\n\r\n        /**\r\n         * Init method to bootstrap all things\r\n         *\r\n         * @return $_obj   The jQuerify tag box\r\n         */\r\n        init: function() {\r\n            // console.log( 'init' );\r\n\r\n            var init_text, self, text;\r\n\r\n            self = this;\r\n\r\n            // Getting all data Parameters to fully customize the single tag box selecteds\r\n            self.config = $.extend( {}, self.defaults, self.options, self.getDataOptions() );\r\n\r\n            // Pre-existent text\r\n            init_text = self.$elem.text();\r\n\r\n            // Empty the original div\r\n            self.$elem.empty();\r\n\r\n            // Create the type_zone input using custom class and contenteditable attribute\r\n            self.$type_zone = $( document.createElement( \"input\" ) )\r\n                             .addClass( self.config[ \"type-zone-class\" ] )\r\n                             .attr( \"contenteditable\", true );\r\n\r\n            // Adding tagging class and appending the type zone\r\n            self.$elem\r\n                .addClass( self.config[ \"tag-box-class\" ] )\r\n                .append( self.$type_zone );\r\n\r\n            // Keydown event listener on tag box type_zone\r\n            self.$type_zone.keydown(function( e ) {\r\n                var key, index, l, pressed_key, all_keys,\r\n                    forbidden_chars, actual_text,\r\n                    callback_f, callback_t;\r\n\r\n                all_keys = self.getSpecialKeys();\r\n\r\n                // Forbidden Chars shortcut\r\n                forbidden_chars = self.config[ \"forbidden-chars\" ];\r\n\r\n                // Actual text in the type_zone\r\n                actual_text     = self.valInput();\r\n\r\n                // The pressed key\r\n                pressed_key     = e.which;\r\n\r\n                // console.log( pressed_key );\r\n\r\n                // For in loop to look to Remove Keys\r\n                if ( ! actual_text ) {\r\n\r\n                    for ( key in all_keys ) {\r\n\r\n                        // Some special key\r\n                        if ( pressed_key === all_keys[ key ] ) {\r\n\r\n                            // Enter or comma or spacebar - We cannot add an empty tag\r\n                            if ( self.keys.add[ key ] /*!= null*/ ) {\r\n\r\n                                // Prevent Default\r\n                                e.preventDefault();\r\n\r\n                                // Exit with 'true'\r\n                                return true;\r\n                            }\r\n\r\n                            // Backspace or Del\r\n                            if ( self.keys.remove[ key ] /*!= null*/ ) {\r\n\r\n                                // Checking if it enabled\r\n                                if ( ! self.config[ \"no-\" + key ] ) {\r\n\r\n                                    // Prevent Default\r\n                                    e.preventDefault();\r\n\r\n                                    return self.remove();\r\n\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n\r\n                    // For loop to remove Forbidden Chars from Text\r\n                    l = forbidden_chars.length;\r\n                    while ( l-- ) {\r\n\r\n                        // Looking for a forbidden char\r\n                        index = actual_text.indexOf( forbidden_chars[ l ] );\r\n\r\n                        // There is a forbidden text\r\n                        if ( index >= 0 ) {\r\n\r\n                            // Prevent Default\r\n                            e.preventDefault();\r\n\r\n                            // Removing Forbidden Char\r\n                            actual_text = actual_text.replace( forbidden_chars[ l ], \"\" );\r\n\r\n                            // Update type_zone text\r\n                            self.focusInput();\r\n                            self.valInput( actual_text );\r\n\r\n                            // Renaiming\r\n                            callback_f = self.config[ \"forbidden-chars-callback\" ];\r\n                            callback_t = self.config[ \"forbidden-chars-text\" ];\r\n\r\n                            // Remove the duplicate\r\n                            return self.throwError( callback_f, callback_t, forbidden_chars[ l ] );\r\n                        }\r\n                    }\r\n\r\n                    // For in to look in Add Keys\r\n                    for ( key in self.keys.add ) {\r\n\r\n                        // Enter or comma or spacebar if enabled\r\n                        if ( pressed_key === self.keys.add[ key ] ) {\r\n\r\n                            if ( ! self.config[ \"no-\" + key ] ) {\r\n\r\n                                // Prevent Default\r\n                                e.preventDefault();\r\n\r\n                                // Adding tag with no text\r\n                                return self.add();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Exit with success\r\n                return true;\r\n            });\r\n\r\n            // Add tag on a click away from the type_zone\r\n            if ( self.config[ \"tag-on-blur\" ] ) {\r\n                self.$type_zone.focusout(function() {\r\n\r\n                    // Get text from current input box\r\n                    text = self.valInput();\r\n\r\n                    // If text is empty, then continue focusout\r\n                    if ( ! text || ! text.length ) {\r\n                        return false;\r\n                    }\r\n\r\n                    // Otherwise add the tag first\r\n                    return self.add();\r\n                });\r\n            }\r\n\r\n            // On click, we focus the type_zone\r\n            self.$elem.on( \"click\", function() {\r\n                self.focusInput();\r\n            });\r\n\r\n            // Refresh tag box using refresh public method with a text\r\n            self.refresh( init_text );\r\n\r\n            // We don't break the chain, right?\r\n            return self;\r\n        },\r\n\r\n        /**\r\n         * Remove and insert all tag\r\n         *\r\n         * @param  string  text String with all tags (if null, simply we call getTags method)\r\n         * @return boolean\r\n         */\r\n        refresh: function( text ) {\r\n            // console.log( 'refresh' );\r\n\r\n            var self, separator;\r\n\r\n            self = this;\r\n            separator = self.config[ \"pre-tags-separator\" ];\r\n\r\n            text = text || self.getTags().join( separator );\r\n\r\n            self.reset();\r\n\r\n            // Adding text present on type_zone as tag on first call\r\n            $.each( text.split( separator ), function() {\r\n                self.add( this + \"\" );\r\n            });\r\n\r\n            return true;\r\n        },\r\n\r\n        /**\r\n         * Remove last tag in tag box's type_zone or a specified one.\r\n         *\r\n         * @param  string|$_obj         The text of tag to remove or the $_obj of itself.\r\n         * @return string|$_obj         An error if the tag is not found, or the $_obj of removed tag.\r\n         */\r\n        remove: function( $tag ) {\r\n            // console.log( 'remove' );\r\n\r\n            var self, text, l;\r\n\r\n            self = this;\r\n\r\n            // If $tag is an array, call remove on each element\r\n            if ( $.isArray( $tag ) ) {\r\n                // Adding text present on type_zone as tag on first call\r\n                return $.each( $tag, function() {\r\n                    self.remove( this + \"\" );\r\n                });\r\n            }\r\n\r\n            // If $tag is a string, we must find the $_obj of the tag\r\n            if ( typeof $tag === \"string\" ) {\r\n\r\n                // Renaiming\r\n                text = $tag;\r\n\r\n                // Retrieving the $_obj of the tag\r\n                $tag = self.$elem.find( \"input[value=\" + text + \"]\" ).parent();\r\n\r\n                // If nothing is found, return an error\r\n                if ( ! $tag.length ) {\r\n                    return \"Error -> Tag not found\";\r\n                }\r\n            }\r\n\r\n            // Not specified any tags\r\n            if ( ! $tag ) {\r\n\r\n                // Retrieving the last\r\n                $tag = self.tags.pop();\r\n\r\n            } else {\r\n\r\n                // Iterate the tags array and removing the specified tags\r\n                l = self.tags.length;\r\n                while ( l-- ) {\r\n                    // Confront the content of $tag and the tags array\r\n                    if ( self.tags[ l ][0].innerHTML === $tag[0].innerHTML ) {\r\n                        // Removing definitively\r\n                        self.tags.splice( l, 1 );\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Getting text if not alredy setted\r\n            text = text || $tag.pure_text;\r\n\r\n            // Removing last tag\r\n            $tag.remove();\r\n\r\n            // If you want to change the text when a tag is deleted\r\n            if ( self.config[ \"edit-on-delete\" ] ) {\r\n\r\n                // Empting input\r\n                self.emptyInput();\r\n\r\n                // Set the new text\r\n                self.valInput( $tag.pure_text );\r\n            }\r\n\r\n            return $tag;\r\n\r\n        },\r\n\r\n        /**\r\n         * Alias of reset\r\n         *\r\n         * @return array  All removed tags\r\n         */\r\n        removeAll: function() {\r\n            // console.log( 'removeAll' );\r\n\r\n            return this.reset();\r\n        },\r\n\r\n        /**\r\n         * Remove a special keys\r\n         *\r\n         * @param  array  arr  Array like ['type', key_code], where 'type' is 'add' or 'remove', key_code is the key number\r\n         * @return obj         Actually 'type'_key (add_key or remove_key).\r\n         */\r\n        removeSpecialKeys: function( arr ) {\r\n            // console.log( 'removeSpecialKeys' );\r\n\r\n            var self, value, to_add, key_code, type;\r\n\r\n            self     = this;\r\n            type     = arr[0];\r\n            key_code = arr[1];\r\n            to_add   = {};\r\n\r\n            // If key_code is an array, call removeSpecialKeys on each element\r\n            if ( $.isArray( key_code ) ) {\r\n                return $.each( key_code, function() {\r\n                    self.removeSpecialKeys( [ type, this ] );\r\n                });\r\n            }\r\n\r\n            // Iterate proper array\r\n            for ( value in self.keys[ type ] ) {\r\n                if ( self.keys[ type ].hasOwnProperty( value ) ) {\r\n\r\n                    // If the key_code is equal to the actual key_code\r\n                    if ( self.keys[ type ][ value ] === key_code ) {\r\n                        // We set to undefined the property\r\n                        self.keys[ type ][ value ] = undefined;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return self.keys[ type ];\r\n        },\r\n\r\n        /**\r\n         * Remove all tags from tag box's type_zone\r\n         *\r\n         * @return array  All removed tags\r\n         */\r\n        reset: function() {\r\n            // console.log( 'reset' );\r\n\r\n            while (this.tags.length ) {\r\n                this.remove( this.tags[ this.tags.length ] );\r\n            }\r\n\r\n            this.emptyInput();\r\n\r\n            return this.tags;\r\n\r\n        },\r\n\r\n        /**\r\n         * Raise a callback with some text\r\n         *\r\n         * @param  function callback_f Callback function\r\n         * @param  string   callback_t Basic text\r\n         * @param  string   tag_text   Tag text\r\n         * @return function\r\n         */\r\n        throwError: function( callback_f, callback_t, tag_text ) {\r\n            // Calling the callback with t as th\r\n            return callback_f( [ callback_t + \" '\" + tag_text + \"'.\" ] );\r\n        },\r\n\r\n        /**\r\n         * Get or Set the tag box type_zone's value\r\n         *\r\n         * @param  string        text String to put as tag box type_zone's value\r\n         * @return string|$_obj       The value of tag box's type_zone or the type_zone itself\r\n         */\r\n        valInput: function( text ) {\r\n            // console.log( 'valInput' );\r\n\r\n            if ( text == null ) {\r\n                return this.$type_zone.val();\r\n            }\r\n\r\n            return this.$type_zone.val( text );\r\n\r\n        },\r\n\r\n    };\r\n\r\n    /**\r\n     * Registering taggingJS\r\n     *\r\n     * @param  obj|string arg1 Object with custom options or string with a method\r\n     * @param  string     arg2 Argument to pass to the method\r\n     * @return $_Obj           All tag-box or result from \"arg2\" public method.\r\n     */\r\n    $.fn.tagging = function( arg1, arg2 ) {\r\n        var results = [];\r\n\r\n        this.each(function() {\r\n            var $this, tagging, val;\r\n\r\n            $this   = $( this );\r\n            tagging = $this.data( \"tag-box\" );\r\n\r\n            // Initialize a new tags input\r\n            if ( ! tagging ) {\r\n\r\n                tagging = new Tagging( this, arg1 );\r\n\r\n                $this.data( \"tag-box\", tagging );\r\n\r\n                tagging.init();\r\n\r\n                results.push( tagging.$elem );\r\n\r\n            } else {\r\n\r\n                // Invoke function on existing tags input\r\n                val = tagging[ arg1 ]( arg2 );\r\n\r\n                if ( val /*!= null*/ ) {\r\n                    results.push( val );\r\n                }\r\n            }\r\n        });\r\n\r\n        if ( typeof arg1 === \"string\") {\r\n            // Return the results from the invoked function calls\r\n            return ( results.length > 1 ) ? results : results[0];\r\n        }\r\n\r\n        return results;\r\n    };\r\n\r\n})( window.jQuery, window, document );\r\n\r\n// jQuery on Ready example\r\n// (function( $, window, document, undefined ) {\r\n//     $( document ).ready(function() {\r\n//         var t = $( \".tagging-js\" ).tagging();\r\n//         t[0].addClass( \"form-control\" );\r\n//         // console.log( t[0] );\r\n//     });\r\n// })( window.jQuery, window, document );\r\n"],"sourceRoot":"/source/"}