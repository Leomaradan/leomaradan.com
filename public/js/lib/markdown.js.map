{"version":3,"sources":["markdown.js","to-markdown.js","bootstrap-markdown.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7rDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"markdown.js","sourcesContent":["// Released under MIT license\r\n// Copyright (c) 2009-2010 Dominic Baggott\r\n// Copyright (c) 2009-2010 Ash Berlin\r\n// Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)\r\n\r\n/*jshint browser:true, devel:true */\r\n\r\n(function( expose ) {\r\n\r\n/**\r\n *  class Markdown\r\n *\r\n *  Markdown processing in Javascript done right. We have very particular views\r\n *  on what constitutes 'right' which include:\r\n *\r\n *  - produces well-formed HTML (this means that em and strong nesting is\r\n *    important)\r\n *\r\n *  - has an intermediate representation to allow processing of parsed data (We\r\n *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).\r\n *\r\n *  - is easily extensible to add new dialects without having to rewrite the\r\n *    entire parsing mechanics\r\n *\r\n *  - has a good test suite\r\n *\r\n *  This implementation fulfills all of these (except that the test suite could\r\n *  do with expanding to automatically run all the fixtures from other Markdown\r\n *  implementations.)\r\n *\r\n *  ##### Intermediate Representation\r\n *\r\n *  *TODO* Talk about this :) Its JsonML, but document the node names we use.\r\n *\r\n *  [JsonML]: http://jsonml.org/ \"JSON Markup Language\"\r\n **/\r\nvar Markdown = expose.Markdown = function(dialect) {\r\n  switch (typeof dialect) {\r\n    case \"undefined\":\r\n      this.dialect = Markdown.dialects.Gruber;\r\n      break;\r\n    case \"object\":\r\n      this.dialect = dialect;\r\n      break;\r\n    default:\r\n      if ( dialect in Markdown.dialects ) {\r\n        this.dialect = Markdown.dialects[dialect];\r\n      }\r\n      else {\r\n        throw new Error(\"Unknown Markdown dialect '\" + String(dialect) + \"'\");\r\n      }\r\n      break;\r\n  }\r\n  this.em_state = [];\r\n  this.strong_state = [];\r\n  this.debug_indent = \"\";\r\n};\r\n\r\n/**\r\n *  parse( markdown, [dialect] ) -> JsonML\r\n *  - markdown (String): markdown string to parse\r\n *  - dialect (String | Dialect): the dialect to use, defaults to gruber\r\n *\r\n *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.\r\n **/\r\nexpose.parse = function( source, dialect ) {\r\n  // dialect will default if undefined\r\n  var md = new Markdown( dialect );\r\n  return md.toTree( source );\r\n};\r\n\r\n/**\r\n *  toHTML( markdown, [dialect]  ) -> String\r\n *  toHTML( md_tree ) -> String\r\n *  - markdown (String): markdown string to parse\r\n *  - md_tree (Markdown.JsonML): parsed markdown tree\r\n *\r\n *  Take markdown (either as a string or as a JsonML tree) and run it through\r\n *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.\r\n **/\r\nexpose.toHTML = function toHTML( source , dialect , options ) {\r\n  var input = expose.toHTMLTree( source , dialect , options );\r\n\r\n  return expose.renderJsonML( input );\r\n};\r\n\r\n/**\r\n *  toHTMLTree( markdown, [dialect] ) -> JsonML\r\n *  toHTMLTree( md_tree ) -> JsonML\r\n *  - markdown (String): markdown string to parse\r\n *  - dialect (String | Dialect): the dialect to use, defaults to gruber\r\n *  - md_tree (Markdown.JsonML): parsed markdown tree\r\n *\r\n *  Turn markdown into HTML, represented as a JsonML tree. If a string is given\r\n *  to this function, it is first parsed into a markdown tree by calling\r\n *  [[parse]].\r\n **/\r\nexpose.toHTMLTree = function toHTMLTree( input, dialect , options ) {\r\n  // convert string input to an MD tree\r\n  if ( typeof input ===\"string\" ) input = this.parse( input, dialect );\r\n\r\n  // Now convert the MD tree to an HTML tree\r\n\r\n  // remove references from the tree\r\n  var attrs = extract_attr( input ),\r\n      refs = {};\r\n\r\n  if ( attrs && attrs.references ) {\r\n    refs = attrs.references;\r\n  }\r\n\r\n  var html = convert_tree_to_html( input, refs , options );\r\n  merge_text_nodes( html );\r\n  return html;\r\n};\r\n\r\n// For Spidermonkey based engines\r\nfunction mk_block_toSource() {\r\n  return \"Markdown.mk_block( \" +\r\n          uneval(this.toString()) +\r\n          \", \" +\r\n          uneval(this.trailing) +\r\n          \", \" +\r\n          uneval(this.lineNumber) +\r\n          \" )\";\r\n}\r\n\r\n// node\r\nfunction mk_block_inspect() {\r\n  var util = require(\"util\");\r\n  return \"Markdown.mk_block( \" +\r\n          util.inspect(this.toString()) +\r\n          \", \" +\r\n          util.inspect(this.trailing) +\r\n          \", \" +\r\n          util.inspect(this.lineNumber) +\r\n          \" )\";\r\n\r\n}\r\n\r\nvar mk_block = Markdown.mk_block = function(block, trail, line) {\r\n  // Be helpful for default case in tests.\r\n  if ( arguments.length == 1 ) trail = \"\\n\\n\";\r\n\r\n  var s = new String(block);\r\n  s.trailing = trail;\r\n  // To make it clear its not just a string\r\n  s.inspect = mk_block_inspect;\r\n  s.toSource = mk_block_toSource;\r\n\r\n  if ( line != undefined )\r\n    s.lineNumber = line;\r\n\r\n  return s;\r\n};\r\n\r\nfunction count_lines( str ) {\r\n  var n = 0, i = -1;\r\n  while ( ( i = str.indexOf(\"\\n\", i + 1) ) !== -1 ) n++;\r\n  return n;\r\n}\r\n\r\n// Internal - split source into rough blocks\r\nMarkdown.prototype.split_blocks = function splitBlocks( input, startLine ) {\r\n  input = input.replace(/(\\r\\n|\\n|\\r)/g, \"\\n\");\r\n  // [\\s\\S] matches _anything_ (newline or space)\r\n  // [^] is equivalent but doesn't work in IEs.\r\n  var re = /([\\s\\S]+?)($|\\n#|\\n(?:\\s*\\n|$)+)/g,\r\n      blocks = [],\r\n      m;\r\n\r\n  var line_no = 1;\r\n\r\n  if ( ( m = /^(\\s*\\n)/.exec(input) ) != null ) {\r\n    // skip (but count) leading blank lines\r\n    line_no += count_lines( m[0] );\r\n    re.lastIndex = m[0].length;\r\n  }\r\n\r\n  while ( ( m = re.exec(input) ) !== null ) {\r\n    if (m[2] == \"\\n#\") {\r\n      m[2] = \"\\n\";\r\n      re.lastIndex--;\r\n    }\r\n    blocks.push( mk_block( m[1], m[2], line_no ) );\r\n    line_no += count_lines( m[0] );\r\n  }\r\n\r\n  return blocks;\r\n};\r\n\r\n/**\r\n *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]\r\n *  - block (String): the block to process\r\n *  - next (Array): the following blocks\r\n *\r\n * Process `block` and return an array of JsonML nodes representing `block`.\r\n *\r\n * It does this by asking each block level function in the dialect to process\r\n * the block until one can. Succesful handling is indicated by returning an\r\n * array (with zero or more JsonML nodes), failure by a false value.\r\n *\r\n * Blocks handlers are responsible for calling [[Markdown#processInline]]\r\n * themselves as appropriate.\r\n *\r\n * If the blocks were split incorrectly or adjacent blocks need collapsing you\r\n * can adjust `next` in place using shift/splice etc.\r\n *\r\n * If any of this default behaviour is not right for the dialect, you can\r\n * define a `__call__` method on the dialect that will get invoked to handle\r\n * the block processing.\r\n */\r\nMarkdown.prototype.processBlock = function processBlock( block, next ) {\r\n  var cbs = this.dialect.block,\r\n      ord = cbs.__order__;\r\n\r\n  if ( \"__call__\" in cbs ) {\r\n    return cbs.__call__.call(this, block, next);\r\n  }\r\n\r\n  for ( var i = 0; i < ord.length; i++ ) {\r\n    //D:this.debug( \"Testing\", ord[i] );\r\n    var res = cbs[ ord[i] ].call( this, block, next );\r\n    if ( res ) {\r\n      //D:this.debug(\"  matched\");\r\n      if ( !isArray(res) || ( res.length > 0 && !( isArray(res[0]) ) ) )\r\n        this.debug(ord[i], \"didn't return a proper array\");\r\n      //D:this.debug( \"\" );\r\n      return res;\r\n    }\r\n  }\r\n\r\n  // Uhoh! no match! Should we throw an error?\r\n  return [];\r\n};\r\n\r\nMarkdown.prototype.processInline = function processInline( block ) {\r\n  return this.dialect.inline.__call__.call( this, String( block ) );\r\n};\r\n\r\n/**\r\n *  Markdown#toTree( source ) -> JsonML\r\n *  - source (String): markdown source to parse\r\n *\r\n *  Parse `source` into a JsonML tree representing the markdown document.\r\n **/\r\n// custom_tree means set this.tree to `custom_tree` and restore old value on return\r\nMarkdown.prototype.toTree = function toTree( source, custom_root ) {\r\n  var blocks = source instanceof Array ? source : this.split_blocks( source );\r\n\r\n  // Make tree a member variable so its easier to mess with in extensions\r\n  var old_tree = this.tree;\r\n  try {\r\n    this.tree = custom_root || this.tree || [ \"markdown\" ];\r\n\r\n    blocks:\r\n    while ( blocks.length ) {\r\n      var b = this.processBlock( blocks.shift(), blocks );\r\n\r\n      // Reference blocks and the like won't return any content\r\n      if ( !b.length ) continue blocks;\r\n\r\n      this.tree.push.apply( this.tree, b );\r\n    }\r\n    return this.tree;\r\n  }\r\n  finally {\r\n    if ( custom_root ) {\r\n      this.tree = old_tree;\r\n    }\r\n  }\r\n};\r\n\r\n// Noop by default\r\nMarkdown.prototype.debug = function () {\r\n  var args = Array.prototype.slice.call( arguments);\r\n  args.unshift(this.debug_indent);\r\n  if ( typeof print !== \"undefined\" )\r\n      print.apply( print, args );\r\n  if ( typeof console !== \"undefined\" && typeof console.log !== \"undefined\" )\r\n      console.log.apply( null, args );\r\n}\r\n\r\nMarkdown.prototype.loop_re_over_block = function( re, block, cb ) {\r\n  // Dont use /g regexps with this\r\n  var m,\r\n      b = block.valueOf();\r\n\r\n  while ( b.length && (m = re.exec(b) ) != null ) {\r\n    b = b.substr( m[0].length );\r\n    cb.call(this, m);\r\n  }\r\n  return b;\r\n};\r\n\r\n/**\r\n * Markdown.dialects\r\n *\r\n * Namespace of built-in dialects.\r\n **/\r\nMarkdown.dialects = {};\r\n\r\n/**\r\n * Markdown.dialects.Gruber\r\n *\r\n * The default dialect that follows the rules set out by John Gruber's\r\n * markdown.pl as closely as possible. Well actually we follow the behaviour of\r\n * that script which in some places is not exactly what the syntax web page\r\n * says.\r\n **/\r\nMarkdown.dialects.Gruber = {\r\n  block: {\r\n    atxHeader: function atxHeader( block, next ) {\r\n      var m = block.match( /^(#{1,6})\\s*(.*?)\\s*#*\\s*(?:\\n|$)/ );\r\n\r\n      if ( !m ) return undefined;\r\n\r\n      var header = [ \"header\", { level: m[ 1 ].length } ];\r\n      Array.prototype.push.apply(header, this.processInline(m[ 2 ]));\r\n\r\n      if ( m[0].length < block.length )\r\n        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );\r\n\r\n      return [ header ];\r\n    },\r\n\r\n    setextHeader: function setextHeader( block, next ) {\r\n      var m = block.match( /^(.*)\\n([-=])\\2\\2+(?:\\n|$)/ );\r\n\r\n      if ( !m ) return undefined;\r\n\r\n      var level = ( m[ 2 ] === \"=\" ) ? 1 : 2;\r\n      var header = [ \"header\", { level : level }, m[ 1 ] ];\r\n\r\n      if ( m[0].length < block.length )\r\n        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );\r\n\r\n      return [ header ];\r\n    },\r\n\r\n    code: function code( block, next ) {\r\n      // |    Foo\r\n      // |bar\r\n      // should be a code block followed by a paragraph. Fun\r\n      //\r\n      // There might also be adjacent code block to merge.\r\n\r\n      var ret = [],\r\n          re = /^(?: {0,3}\\t| {4})(.*)\\n?/,\r\n          lines;\r\n\r\n      // 4 spaces + content\r\n      if ( !block.match( re ) ) return undefined;\r\n\r\n      block_search:\r\n      do {\r\n        // Now pull out the rest of the lines\r\n        var b = this.loop_re_over_block(\r\n                  re, block.valueOf(), function( m ) { ret.push( m[1] ); } );\r\n\r\n        if ( b.length ) {\r\n          // Case alluded to in first comment. push it back on as a new block\r\n          next.unshift( mk_block(b, block.trailing) );\r\n          break block_search;\r\n        }\r\n        else if ( next.length ) {\r\n          // Check the next block - it might be code too\r\n          if ( !next[0].match( re ) ) break block_search;\r\n\r\n          // Pull how how many blanks lines follow - minus two to account for .join\r\n          ret.push ( block.trailing.replace(/[^\\n]/g, \"\").substring(2) );\r\n\r\n          block = next.shift();\r\n        }\r\n        else {\r\n          break block_search;\r\n        }\r\n      } while ( true );\r\n\r\n      return [ [ \"code_block\", ret.join(\"\\n\") ] ];\r\n    },\r\n\r\n    horizRule: function horizRule( block, next ) {\r\n      // this needs to find any hr in the block to handle abutting blocks\r\n      var m = block.match( /^(?:([\\s\\S]*?)\\n)?[ \\t]*([-_*])(?:[ \\t]*\\2){2,}[ \\t]*(?:\\n([\\s\\S]*))?$/ );\r\n\r\n      if ( !m ) {\r\n        return undefined;\r\n      }\r\n\r\n      var jsonml = [ [ \"hr\" ] ];\r\n\r\n      // if there's a leading abutting block, process it\r\n      if ( m[ 1 ] ) {\r\n        jsonml.unshift.apply( jsonml, this.processBlock( m[ 1 ], [] ) );\r\n      }\r\n\r\n      // if there's a trailing abutting block, stick it into next\r\n      if ( m[ 3 ] ) {\r\n        next.unshift( mk_block( m[ 3 ] ) );\r\n      }\r\n\r\n      return jsonml;\r\n    },\r\n\r\n    // There are two types of lists. Tight and loose. Tight lists have no whitespace\r\n    // between the items (and result in text just in the <li>) and loose lists,\r\n    // which have an empty line between list items, resulting in (one or more)\r\n    // paragraphs inside the <li>.\r\n    //\r\n    // There are all sorts weird edge cases about the original markdown.pl's\r\n    // handling of lists:\r\n    //\r\n    // * Nested lists are supposed to be indented by four chars per level. But\r\n    //   if they aren't, you can get a nested list by indenting by less than\r\n    //   four so long as the indent doesn't match an indent of an existing list\r\n    //   item in the 'nest stack'.\r\n    //\r\n    // * The type of the list (bullet or number) is controlled just by the\r\n    //    first item at the indent. Subsequent changes are ignored unless they\r\n    //    are for nested lists\r\n    //\r\n    lists: (function( ) {\r\n      // Use a closure to hide a few variables.\r\n      var any_list = \"[*+-]|\\\\d+\\\\.\",\r\n          bullet_list = /[*+-]/,\r\n          number_list = /\\d+\\./,\r\n          // Capture leading indent as it matters for determining nested lists.\r\n          is_list_re = new RegExp( \"^( {0,3})(\" + any_list + \")[ \\t]+\" ),\r\n          indent_re = \"(?: {0,3}\\\\t| {4})\";\r\n\r\n      // TODO: Cache this regexp for certain depths.\r\n      // Create a regexp suitable for matching an li for a given stack depth\r\n      function regex_for_depth( depth ) {\r\n\r\n        return new RegExp(\r\n          // m[1] = indent, m[2] = list_type\r\n          \"(?:^(\" + indent_re + \"{0,\" + depth + \"} {0,3})(\" + any_list + \")\\\\s+)|\" +\r\n          // m[3] = cont\r\n          \"(^\" + indent_re + \"{0,\" + (depth-1) + \"}[ ]{0,4})\"\r\n        );\r\n      }\r\n      function expand_tab( input ) {\r\n        return input.replace( / {0,3}\\t/g, \"    \" );\r\n      }\r\n\r\n      // Add inline content `inline` to `li`. inline comes from processInline\r\n      // so is an array of content\r\n      function add(li, loose, inline, nl) {\r\n        if ( loose ) {\r\n          li.push( [ \"para\" ].concat(inline) );\r\n          return;\r\n        }\r\n        // Hmmm, should this be any block level element or just paras?\r\n        var add_to = li[li.length -1] instanceof Array && li[li.length - 1][0] == \"para\"\r\n                   ? li[li.length -1]\r\n                   : li;\r\n\r\n        // If there is already some content in this list, add the new line in\r\n        if ( nl && li.length > 1 ) inline.unshift(nl);\r\n\r\n        for ( var i = 0; i < inline.length; i++ ) {\r\n          var what = inline[i],\r\n              is_str = typeof what == \"string\";\r\n          if ( is_str && add_to.length > 1 && typeof add_to[add_to.length-1] == \"string\" ) {\r\n            add_to[ add_to.length-1 ] += what;\r\n          }\r\n          else {\r\n            add_to.push( what );\r\n          }\r\n        }\r\n      }\r\n\r\n      // contained means have an indent greater than the current one. On\r\n      // *every* line in the block\r\n      function get_contained_blocks( depth, blocks ) {\r\n\r\n        var re = new RegExp( \"^(\" + indent_re + \"{\" + depth + \"}.*?\\\\n?)*$\" ),\r\n            replace = new RegExp(\"^\" + indent_re + \"{\" + depth + \"}\", \"gm\"),\r\n            ret = [];\r\n\r\n        while ( blocks.length > 0 ) {\r\n          if ( re.exec( blocks[0] ) ) {\r\n            var b = blocks.shift(),\r\n                // Now remove that indent\r\n                x = b.replace( replace, \"\");\r\n\r\n            ret.push( mk_block( x, b.trailing, b.lineNumber ) );\r\n          }\r\n          else {\r\n            break;\r\n          }\r\n        }\r\n        return ret;\r\n      }\r\n\r\n      // passed to stack.forEach to turn list items up the stack into paras\r\n      function paragraphify(s, i, stack) {\r\n        var list = s.list;\r\n        var last_li = list[list.length-1];\r\n\r\n        if ( last_li[1] instanceof Array && last_li[1][0] == \"para\" ) {\r\n          return;\r\n        }\r\n        if ( i + 1 == stack.length ) {\r\n          // Last stack frame\r\n          // Keep the same array, but replace the contents\r\n          last_li.push( [\"para\"].concat( last_li.splice(1, last_li.length - 1) ) );\r\n        }\r\n        else {\r\n          var sublist = last_li.pop();\r\n          last_li.push( [\"para\"].concat( last_li.splice(1, last_li.length - 1) ), sublist );\r\n        }\r\n      }\r\n\r\n      // The matcher function\r\n      return function( block, next ) {\r\n        var m = block.match( is_list_re );\r\n        if ( !m ) return undefined;\r\n\r\n        function make_list( m ) {\r\n          var list = bullet_list.exec( m[2] )\r\n                   ? [\"bulletlist\"]\r\n                   : [\"numberlist\"];\r\n\r\n          stack.push( { list: list, indent: m[1] } );\r\n          return list;\r\n        }\r\n\r\n\r\n        var stack = [], // Stack of lists for nesting.\r\n            list = make_list( m ),\r\n            last_li,\r\n            loose = false,\r\n            ret = [ stack[0].list ],\r\n            i;\r\n\r\n        // Loop to search over block looking for inner block elements and loose lists\r\n        loose_search:\r\n        while ( true ) {\r\n          // Split into lines preserving new lines at end of line\r\n          var lines = block.split( /(?=\\n)/ );\r\n\r\n          // We have to grab all lines for a li and call processInline on them\r\n          // once as there are some inline things that can span lines.\r\n          var li_accumulate = \"\";\r\n\r\n          // Loop over the lines in this block looking for tight lists.\r\n          tight_search:\r\n          for ( var line_no = 0; line_no < lines.length; line_no++ ) {\r\n            var nl = \"\",\r\n                l = lines[line_no].replace(/^\\n/, function(n) { nl = n; return \"\"; });\r\n\r\n            // TODO: really should cache this\r\n            var line_re = regex_for_depth( stack.length );\r\n\r\n            m = l.match( line_re );\r\n            //print( \"line:\", uneval(l), \"\\nline match:\", uneval(m) );\r\n\r\n            // We have a list item\r\n            if ( m[1] !== undefined ) {\r\n              // Process the previous list item, if any\r\n              if ( li_accumulate.length ) {\r\n                add( last_li, loose, this.processInline( li_accumulate ), nl );\r\n                // Loose mode will have been dealt with. Reset it\r\n                loose = false;\r\n                li_accumulate = \"\";\r\n              }\r\n\r\n              m[1] = expand_tab( m[1] );\r\n              var wanted_depth = Math.floor(m[1].length/4)+1;\r\n              //print( \"want:\", wanted_depth, \"stack:\", stack.length);\r\n              if ( wanted_depth > stack.length ) {\r\n                // Deep enough for a nested list outright\r\n                //print ( \"new nested list\" );\r\n                list = make_list( m );\r\n                last_li.push( list );\r\n                last_li = list[1] = [ \"listitem\" ];\r\n              }\r\n              else {\r\n                // We aren't deep enough to be strictly a new level. This is\r\n                // where Md.pl goes nuts. If the indent matches a level in the\r\n                // stack, put it there, else put it one deeper then the\r\n                // wanted_depth deserves.\r\n                var found = false;\r\n                for ( i = 0; i < stack.length; i++ ) {\r\n                  if ( stack[ i ].indent != m[1] ) continue;\r\n                  list = stack[ i ].list;\r\n                  stack.splice( i+1, stack.length - (i+1) );\r\n                  found = true;\r\n                  break;\r\n                }\r\n\r\n                if (!found) {\r\n                  //print(\"not found. l:\", uneval(l));\r\n                  wanted_depth++;\r\n                  if ( wanted_depth <= stack.length ) {\r\n                    stack.splice(wanted_depth, stack.length - wanted_depth);\r\n                    //print(\"Desired depth now\", wanted_depth, \"stack:\", stack.length);\r\n                    list = stack[wanted_depth-1].list;\r\n                    //print(\"list:\", uneval(list) );\r\n                  }\r\n                  else {\r\n                    //print (\"made new stack for messy indent\");\r\n                    list = make_list(m);\r\n                    last_li.push(list);\r\n                  }\r\n                }\r\n\r\n                //print( uneval(list), \"last\", list === stack[stack.length-1].list );\r\n                last_li = [ \"listitem\" ];\r\n                list.push(last_li);\r\n              } // end depth of shenegains\r\n              nl = \"\";\r\n            }\r\n\r\n            // Add content\r\n            if ( l.length > m[0].length ) {\r\n              li_accumulate += nl + l.substr( m[0].length );\r\n            }\r\n          } // tight_search\r\n\r\n          if ( li_accumulate.length ) {\r\n            add( last_li, loose, this.processInline( li_accumulate ), nl );\r\n            // Loose mode will have been dealt with. Reset it\r\n            loose = false;\r\n            li_accumulate = \"\";\r\n          }\r\n\r\n          // Look at the next block - we might have a loose list. Or an extra\r\n          // paragraph for the current li\r\n          var contained = get_contained_blocks( stack.length, next );\r\n\r\n          // Deal with code blocks or properly nested lists\r\n          if ( contained.length > 0 ) {\r\n            // Make sure all listitems up the stack are paragraphs\r\n            forEach( stack, paragraphify, this);\r\n\r\n            last_li.push.apply( last_li, this.toTree( contained, [] ) );\r\n          }\r\n\r\n          var next_block = next[0] && next[0].valueOf() || \"\";\r\n\r\n          if ( next_block.match(is_list_re) || next_block.match( /^ / ) ) {\r\n            block = next.shift();\r\n\r\n            // Check for an HR following a list: features/lists/hr_abutting\r\n            var hr = this.dialect.block.horizRule( block, next );\r\n\r\n            if ( hr ) {\r\n              ret.push.apply(ret, hr);\r\n              break;\r\n            }\r\n\r\n            // Make sure all listitems up the stack are paragraphs\r\n            forEach( stack, paragraphify, this);\r\n\r\n            loose = true;\r\n            continue loose_search;\r\n          }\r\n          break;\r\n        } // loose_search\r\n\r\n        return ret;\r\n      };\r\n    })(),\r\n\r\n    blockquote: function blockquote( block, next ) {\r\n      if ( !block.match( /^>/m ) )\r\n        return undefined;\r\n\r\n      var jsonml = [];\r\n\r\n      // separate out the leading abutting block, if any. I.e. in this case:\r\n      //\r\n      //  a\r\n      //  > b\r\n      //\r\n      if ( block[ 0 ] != \">\" ) {\r\n        var lines = block.split( /\\n/ ),\r\n            prev = [],\r\n            line_no = block.lineNumber;\r\n\r\n        // keep shifting lines until you find a crotchet\r\n        while ( lines.length && lines[ 0 ][ 0 ] != \">\" ) {\r\n            prev.push( lines.shift() );\r\n            line_no++;\r\n        }\r\n\r\n        var abutting = mk_block( prev.join( \"\\n\" ), \"\\n\", block.lineNumber );\r\n        jsonml.push.apply( jsonml, this.processBlock( abutting, [] ) );\r\n        // reassemble new block of just block quotes!\r\n        block = mk_block( lines.join( \"\\n\" ), block.trailing, line_no );\r\n      }\r\n\r\n\r\n      // if the next block is also a blockquote merge it in\r\n      while ( next.length && next[ 0 ][ 0 ] == \">\" ) {\r\n        var b = next.shift();\r\n        block = mk_block( block + block.trailing + b, b.trailing, block.lineNumber );\r\n      }\r\n\r\n      // Strip off the leading \"> \" and re-process as a block.\r\n      var input = block.replace( /^> ?/gm, \"\" ),\r\n          old_tree = this.tree,\r\n          processedBlock = this.toTree( input, [ \"blockquote\" ] ),\r\n          attr = extract_attr( processedBlock );\r\n\r\n      // If any link references were found get rid of them\r\n      if ( attr && attr.references ) {\r\n        delete attr.references;\r\n        // And then remove the attribute object if it's empty\r\n        if ( isEmpty( attr ) ) {\r\n          processedBlock.splice( 1, 1 );\r\n        }\r\n      }\r\n\r\n      jsonml.push( processedBlock );\r\n      return jsonml;\r\n    },\r\n\r\n    referenceDefn: function referenceDefn( block, next) {\r\n      var re = /^\\s*\\[(.*?)\\]:\\s*(\\S+)(?:\\s+(?:(['\"])(.*?)\\3|\\((.*?)\\)))?\\n?/;\r\n      // interesting matches are [ , ref_id, url, , title, title ]\r\n\r\n      if ( !block.match(re) )\r\n        return undefined;\r\n\r\n      // make an attribute node if it doesn't exist\r\n      if ( !extract_attr( this.tree ) ) {\r\n        this.tree.splice( 1, 0, {} );\r\n      }\r\n\r\n      var attrs = extract_attr( this.tree );\r\n\r\n      // make a references hash if it doesn't exist\r\n      if ( attrs.references === undefined ) {\r\n        attrs.references = {};\r\n      }\r\n\r\n      var b = this.loop_re_over_block(re, block, function( m ) {\r\n\r\n        if ( m[2] && m[2][0] == \"<\" && m[2][m[2].length-1] == \">\" )\r\n          m[2] = m[2].substring( 1, m[2].length - 1 );\r\n\r\n        var ref = attrs.references[ m[1].toLowerCase() ] = {\r\n          href: m[2]\r\n        };\r\n\r\n        if ( m[4] !== undefined )\r\n          ref.title = m[4];\r\n        else if ( m[5] !== undefined )\r\n          ref.title = m[5];\r\n\r\n      } );\r\n\r\n      if ( b.length )\r\n        next.unshift( mk_block( b, block.trailing ) );\r\n\r\n      return [];\r\n    },\r\n\r\n    para: function para( block, next ) {\r\n      // everything's a para!\r\n      return [ [\"para\"].concat( this.processInline( block ) ) ];\r\n    }\r\n  }\r\n};\r\n\r\nMarkdown.dialects.Gruber.inline = {\r\n\r\n    __oneElement__: function oneElement( text, patterns_or_re, previous_nodes ) {\r\n      var m,\r\n          res,\r\n          lastIndex = 0;\r\n\r\n      patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;\r\n      var re = new RegExp( \"([\\\\s\\\\S]*?)(\" + (patterns_or_re.source || patterns_or_re) + \")\" );\r\n\r\n      m = re.exec( text );\r\n      if (!m) {\r\n        // Just boring text\r\n        return [ text.length, text ];\r\n      }\r\n      else if ( m[1] ) {\r\n        // Some un-interesting text matched. Return that first\r\n        return [ m[1].length, m[1] ];\r\n      }\r\n\r\n      var res;\r\n      if ( m[2] in this.dialect.inline ) {\r\n        res = this.dialect.inline[ m[2] ].call(\r\n                  this,\r\n                  text.substr( m.index ), m, previous_nodes || [] );\r\n      }\r\n      // Default for now to make dev easier. just slurp special and output it.\r\n      res = res || [ m[2].length, m[2] ];\r\n      return res;\r\n    },\r\n\r\n    __call__: function inline( text, patterns ) {\r\n\r\n      var out = [],\r\n          res;\r\n\r\n      function add(x) {\r\n        //D:self.debug(\"  adding output\", uneval(x));\r\n        if ( typeof x == \"string\" && typeof out[out.length-1] == \"string\" )\r\n          out[ out.length-1 ] += x;\r\n        else\r\n          out.push(x);\r\n      }\r\n\r\n      while ( text.length > 0 ) {\r\n        res = this.dialect.inline.__oneElement__.call(this, text, patterns, out );\r\n        text = text.substr( res.shift() );\r\n        forEach(res, add )\r\n      }\r\n\r\n      return out;\r\n    },\r\n\r\n    // These characters are intersting elsewhere, so have rules for them so that\r\n    // chunks of plain text blocks don't include them\r\n    \"]\": function () {},\r\n    \"}\": function () {},\r\n\r\n    __escape__ : /^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-]/,\r\n\r\n    \"\\\\\": function escaped( text ) {\r\n      // [ length of input processed, node/children to add... ]\r\n      // Only esacape: \\ ` * _ { } [ ] ( ) # * + - . !\r\n      if ( this.dialect.inline.__escape__.exec( text ) )\r\n        return [ 2, text.charAt( 1 ) ];\r\n      else\r\n        // Not an esacpe\r\n        return [ 1, \"\\\\\" ];\r\n    },\r\n\r\n    \"![\": function image( text ) {\r\n\r\n      // Unlike images, alt text is plain text only. no other elements are\r\n      // allowed in there\r\n\r\n      // ![Alt text](/path/to/img.jpg \"Optional title\")\r\n      //      1          2            3       4         <--- captures\r\n      var m = text.match( /^!\\[(.*?)\\][ \\t]*\\([ \\t]*([^\")]*?)(?:[ \\t]+([\"'])(.*?)\\3)?[ \\t]*\\)/ );\r\n\r\n      if ( m ) {\r\n        if ( m[2] && m[2][0] == \"<\" && m[2][m[2].length-1] == \">\" )\r\n          m[2] = m[2].substring( 1, m[2].length - 1 );\r\n\r\n        m[2] = this.dialect.inline.__call__.call( this, m[2], /\\\\/ )[0];\r\n\r\n        var attrs = { alt: m[1], href: m[2] || \"\" };\r\n        if ( m[4] !== undefined)\r\n          attrs.title = m[4];\r\n\r\n        return [ m[0].length, [ \"img\", attrs ] ];\r\n      }\r\n\r\n      // ![Alt text][id]\r\n      m = text.match( /^!\\[(.*?)\\][ \\t]*\\[(.*?)\\]/ );\r\n\r\n      if ( m ) {\r\n        // We can't check if the reference is known here as it likely wont be\r\n        // found till after. Check it in md tree->hmtl tree conversion\r\n        return [ m[0].length, [ \"img_ref\", { alt: m[1], ref: m[2].toLowerCase(), original: m[0] } ] ];\r\n      }\r\n\r\n      // Just consume the '!['\r\n      return [ 2, \"![\" ];\r\n    },\r\n\r\n    \"[\": function link( text ) {\r\n\r\n      var orig = String(text);\r\n      // Inline content is possible inside `link text`\r\n      var res = Markdown.DialectHelpers.inline_until_char.call( this, text.substr(1), \"]\" );\r\n\r\n      // No closing ']' found. Just consume the [\r\n      if ( !res ) return [ 1, \"[\" ];\r\n\r\n      var consumed = 1 + res[ 0 ],\r\n          children = res[ 1 ],\r\n          link,\r\n          attrs;\r\n\r\n      // At this point the first [...] has been parsed. See what follows to find\r\n      // out which kind of link we are (reference or direct url)\r\n      text = text.substr( consumed );\r\n\r\n      // [link text](/path/to/img.jpg \"Optional title\")\r\n      //                 1            2       3         <--- captures\r\n      // This will capture up to the last paren in the block. We then pull\r\n      // back based on if there a matching ones in the url\r\n      //    ([here](/url/(test))\r\n      // The parens have to be balanced\r\n      var m = text.match( /^\\s*\\([ \\t]*([^\"']*)(?:[ \\t]+([\"'])(.*?)\\2)?[ \\t]*\\)/ );\r\n      if ( m ) {\r\n        var url = m[1];\r\n        consumed += m[0].length;\r\n\r\n        if ( url && url[0] == \"<\" && url[url.length-1] == \">\" )\r\n          url = url.substring( 1, url.length - 1 );\r\n\r\n        // If there is a title we don't have to worry about parens in the url\r\n        if ( !m[3] ) {\r\n          var open_parens = 1; // One open that isn't in the capture\r\n          for ( var len = 0; len < url.length; len++ ) {\r\n            switch ( url[len] ) {\r\n            case \"(\":\r\n              open_parens++;\r\n              break;\r\n            case \")\":\r\n              if ( --open_parens == 0) {\r\n                consumed -= url.length - len;\r\n                url = url.substring(0, len);\r\n              }\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Process escapes only\r\n        url = this.dialect.inline.__call__.call( this, url, /\\\\/ )[0];\r\n\r\n        attrs = { href: url || \"\" };\r\n        if ( m[3] !== undefined)\r\n          attrs.title = m[3];\r\n\r\n        link = [ \"link\", attrs ].concat( children );\r\n        return [ consumed, link ];\r\n      }\r\n\r\n      // [Alt text][id]\r\n      // [Alt text] [id]\r\n      m = text.match( /^\\s*\\[(.*?)\\]/ );\r\n\r\n      if ( m ) {\r\n\r\n        consumed += m[ 0 ].length;\r\n\r\n        // [links][] uses links as its reference\r\n        attrs = { ref: ( m[ 1 ] || String(children) ).toLowerCase(),  original: orig.substr( 0, consumed ) };\r\n\r\n        link = [ \"link_ref\", attrs ].concat( children );\r\n\r\n        // We can't check if the reference is known here as it likely wont be\r\n        // found till after. Check it in md tree->hmtl tree conversion.\r\n        // Store the original so that conversion can revert if the ref isn't found.\r\n        return [ consumed, link ];\r\n      }\r\n\r\n      // [id]\r\n      // Only if id is plain (no formatting.)\r\n      if ( children.length == 1 && typeof children[0] == \"string\" ) {\r\n\r\n        attrs = { ref: children[0].toLowerCase(),  original: orig.substr( 0, consumed ) };\r\n        link = [ \"link_ref\", attrs, children[0] ];\r\n        return [ consumed, link ];\r\n      }\r\n\r\n      // Just consume the \"[\"\r\n      return [ 1, \"[\" ];\r\n    },\r\n\r\n\r\n    \"<\": function autoLink( text ) {\r\n      var m;\r\n\r\n      if ( ( m = text.match( /^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\\.[a-zA-Z]+))>/ ) ) != null ) {\r\n        if ( m[3] ) {\r\n          return [ m[0].length, [ \"link\", { href: \"mailto:\" + m[3] }, m[3] ] ];\r\n\r\n        }\r\n        else if ( m[2] == \"mailto\" ) {\r\n          return [ m[0].length, [ \"link\", { href: m[1] }, m[1].substr(\"mailto:\".length ) ] ];\r\n        }\r\n        else\r\n          return [ m[0].length, [ \"link\", { href: m[1] }, m[1] ] ];\r\n      }\r\n\r\n      return [ 1, \"<\" ];\r\n    },\r\n\r\n    \"`\": function inlineCode( text ) {\r\n      // Inline code block. as many backticks as you like to start it\r\n      // Always skip over the opening ticks.\r\n      var m = text.match( /(`+)(([\\s\\S]*?)\\1)/ );\r\n\r\n      if ( m && m[2] )\r\n        return [ m[1].length + m[2].length, [ \"inlinecode\", m[3] ] ];\r\n      else {\r\n        // TODO: No matching end code found - warn!\r\n        return [ 1, \"`\" ];\r\n      }\r\n    },\r\n\r\n    \"  \\n\": function lineBreak( text ) {\r\n      return [ 3, [ \"linebreak\" ] ];\r\n    }\r\n\r\n};\r\n\r\n// Meta Helper/generator method for em and strong handling\r\nfunction strong_em( tag, md ) {\r\n\r\n  var state_slot = tag + \"_state\",\r\n      other_slot = tag == \"strong\" ? \"em_state\" : \"strong_state\";\r\n\r\n  function CloseTag(len) {\r\n    this.len_after = len;\r\n    this.name = \"close_\" + md;\r\n  }\r\n\r\n  return function ( text, orig_match ) {\r\n\r\n    if ( this[state_slot][0] == md ) {\r\n      // Most recent em is of this type\r\n      //D:this.debug(\"closing\", md);\r\n      this[state_slot].shift();\r\n\r\n      // \"Consume\" everything to go back to the recrusion in the else-block below\r\n      return[ text.length, new CloseTag(text.length-md.length) ];\r\n    }\r\n    else {\r\n      // Store a clone of the em/strong states\r\n      var other = this[other_slot].slice(),\r\n          state = this[state_slot].slice();\r\n\r\n      this[state_slot].unshift(md);\r\n\r\n      //D:this.debug_indent += \"  \";\r\n\r\n      // Recurse\r\n      var res = this.processInline( text.substr( md.length ) );\r\n      //D:this.debug_indent = this.debug_indent.substr(2);\r\n\r\n      var last = res[res.length - 1];\r\n\r\n      //D:this.debug(\"processInline from\", tag + \": \", uneval( res ) );\r\n\r\n      var check = this[state_slot].shift();\r\n      if ( last instanceof CloseTag ) {\r\n        res.pop();\r\n        // We matched! Huzzah.\r\n        var consumed = text.length - last.len_after;\r\n        return [ consumed, [ tag ].concat(res) ];\r\n      }\r\n      else {\r\n        // Restore the state of the other kind. We might have mistakenly closed it.\r\n        this[other_slot] = other;\r\n        this[state_slot] = state;\r\n\r\n        // We can't reuse the processed result as it could have wrong parsing contexts in it.\r\n        return [ md.length, md ];\r\n      }\r\n    }\r\n  }; // End returned function\r\n}\r\n\r\nMarkdown.dialects.Gruber.inline[\"**\"] = strong_em(\"strong\", \"**\");\r\nMarkdown.dialects.Gruber.inline[\"__\"] = strong_em(\"strong\", \"__\");\r\nMarkdown.dialects.Gruber.inline[\"*\"]  = strong_em(\"em\", \"*\");\r\nMarkdown.dialects.Gruber.inline[\"_\"]  = strong_em(\"em\", \"_\");\r\n\r\n\r\n// Build default order from insertion order.\r\nMarkdown.buildBlockOrder = function(d) {\r\n  var ord = [];\r\n  for ( var i in d ) {\r\n    if ( i == \"__order__\" || i == \"__call__\" ) continue;\r\n    ord.push( i );\r\n  }\r\n  d.__order__ = ord;\r\n};\r\n\r\n// Build patterns for inline matcher\r\nMarkdown.buildInlinePatterns = function(d) {\r\n  var patterns = [];\r\n\r\n  for ( var i in d ) {\r\n    // __foo__ is reserved and not a pattern\r\n    if ( i.match( /^__.*__$/) ) continue;\r\n    var l = i.replace( /([\\\\.*+?|()\\[\\]{}])/g, \"\\\\$1\" )\r\n             .replace( /\\n/, \"\\\\n\" );\r\n    patterns.push( i.length == 1 ? l : \"(?:\" + l + \")\" );\r\n  }\r\n\r\n  patterns = patterns.join(\"|\");\r\n  d.__patterns__ = patterns;\r\n  //print(\"patterns:\", uneval( patterns ) );\r\n\r\n  var fn = d.__call__;\r\n  d.__call__ = function(text, pattern) {\r\n    if ( pattern != undefined ) {\r\n      return fn.call(this, text, pattern);\r\n    }\r\n    else\r\n    {\r\n      return fn.call(this, text, patterns);\r\n    }\r\n  };\r\n};\r\n\r\nMarkdown.DialectHelpers = {};\r\nMarkdown.DialectHelpers.inline_until_char = function( text, want ) {\r\n  var consumed = 0,\r\n      nodes = [];\r\n\r\n  while ( true ) {\r\n    if ( text.charAt( consumed ) == want ) {\r\n      // Found the character we were looking for\r\n      consumed++;\r\n      return [ consumed, nodes ];\r\n    }\r\n\r\n    if ( consumed >= text.length ) {\r\n      // No closing char found. Abort.\r\n      return null;\r\n    }\r\n\r\n    var res = this.dialect.inline.__oneElement__.call(this, text.substr( consumed ) );\r\n    consumed += res[ 0 ];\r\n    // Add any returned nodes.\r\n    nodes.push.apply( nodes, res.slice( 1 ) );\r\n  }\r\n}\r\n\r\n// Helper function to make sub-classing a dialect easier\r\nMarkdown.subclassDialect = function( d ) {\r\n  function Block() {}\r\n  Block.prototype = d.block;\r\n  function Inline() {}\r\n  Inline.prototype = d.inline;\r\n\r\n  return { block: new Block(), inline: new Inline() };\r\n};\r\n\r\nMarkdown.buildBlockOrder ( Markdown.dialects.Gruber.block );\r\nMarkdown.buildInlinePatterns( Markdown.dialects.Gruber.inline );\r\n\r\nMarkdown.dialects.Maruku = Markdown.subclassDialect( Markdown.dialects.Gruber );\r\n\r\nMarkdown.dialects.Maruku.processMetaHash = function processMetaHash( meta_string ) {\r\n  var meta = split_meta_hash( meta_string ),\r\n      attr = {};\r\n\r\n  for ( var i = 0; i < meta.length; ++i ) {\r\n    // id: #foo\r\n    if ( /^#/.test( meta[ i ] ) ) {\r\n      attr.id = meta[ i ].substring( 1 );\r\n    }\r\n    // class: .foo\r\n    else if ( /^\\./.test( meta[ i ] ) ) {\r\n      // if class already exists, append the new one\r\n      if ( attr[\"class\"] ) {\r\n        attr[\"class\"] = attr[\"class\"] + meta[ i ].replace( /./, \" \" );\r\n      }\r\n      else {\r\n        attr[\"class\"] = meta[ i ].substring( 1 );\r\n      }\r\n    }\r\n    // attribute: foo=bar\r\n    else if ( /\\=/.test( meta[ i ] ) ) {\r\n      var s = meta[ i ].split( /\\=/ );\r\n      attr[ s[ 0 ] ] = s[ 1 ];\r\n    }\r\n  }\r\n\r\n  return attr;\r\n}\r\n\r\nfunction split_meta_hash( meta_string ) {\r\n  var meta = meta_string.split( \"\" ),\r\n      parts = [ \"\" ],\r\n      in_quotes = false;\r\n\r\n  while ( meta.length ) {\r\n    var letter = meta.shift();\r\n    switch ( letter ) {\r\n      case \" \" :\r\n        // if we're in a quoted section, keep it\r\n        if ( in_quotes ) {\r\n          parts[ parts.length - 1 ] += letter;\r\n        }\r\n        // otherwise make a new part\r\n        else {\r\n          parts.push( \"\" );\r\n        }\r\n        break;\r\n      case \"'\" :\r\n      case '\"' :\r\n        // reverse the quotes and move straight on\r\n        in_quotes = !in_quotes;\r\n        break;\r\n      case \"\\\\\" :\r\n        // shift off the next letter to be used straight away.\r\n        // it was escaped so we'll keep it whatever it is\r\n        letter = meta.shift();\r\n      default :\r\n        parts[ parts.length - 1 ] += letter;\r\n        break;\r\n    }\r\n  }\r\n\r\n  return parts;\r\n}\r\n\r\nMarkdown.dialects.Maruku.block.document_meta = function document_meta( block, next ) {\r\n  // we're only interested in the first block\r\n  if ( block.lineNumber > 1 ) return undefined;\r\n\r\n  // document_meta blocks consist of one or more lines of `Key: Value\\n`\r\n  if ( ! block.match( /^(?:\\w+:.*\\n)*\\w+:.*$/ ) ) return undefined;\r\n\r\n  // make an attribute node if it doesn't exist\r\n  if ( !extract_attr( this.tree ) ) {\r\n    this.tree.splice( 1, 0, {} );\r\n  }\r\n\r\n  var pairs = block.split( /\\n/ );\r\n  for ( p in pairs ) {\r\n    var m = pairs[ p ].match( /(\\w+):\\s*(.*)$/ ),\r\n        key = m[ 1 ].toLowerCase(),\r\n        value = m[ 2 ];\r\n\r\n    this.tree[ 1 ][ key ] = value;\r\n  }\r\n\r\n  // document_meta produces no content!\r\n  return [];\r\n};\r\n\r\nMarkdown.dialects.Maruku.block.block_meta = function block_meta( block, next ) {\r\n  // check if the last line of the block is an meta hash\r\n  var m = block.match( /(^|\\n) {0,3}\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}$/ );\r\n  if ( !m ) return undefined;\r\n\r\n  // process the meta hash\r\n  var attr = this.dialect.processMetaHash( m[ 2 ] );\r\n\r\n  var hash;\r\n\r\n  // if we matched ^ then we need to apply meta to the previous block\r\n  if ( m[ 1 ] === \"\" ) {\r\n    var node = this.tree[ this.tree.length - 1 ];\r\n    hash = extract_attr( node );\r\n\r\n    // if the node is a string (rather than JsonML), bail\r\n    if ( typeof node === \"string\" ) return undefined;\r\n\r\n    // create the attribute hash if it doesn't exist\r\n    if ( !hash ) {\r\n      hash = {};\r\n      node.splice( 1, 0, hash );\r\n    }\r\n\r\n    // add the attributes in\r\n    for ( a in attr ) {\r\n      hash[ a ] = attr[ a ];\r\n    }\r\n\r\n    // return nothing so the meta hash is removed\r\n    return [];\r\n  }\r\n\r\n  // pull the meta hash off the block and process what's left\r\n  var b = block.replace( /\\n.*$/, \"\" ),\r\n      result = this.processBlock( b, [] );\r\n\r\n  // get or make the attributes hash\r\n  hash = extract_attr( result[ 0 ] );\r\n  if ( !hash ) {\r\n    hash = {};\r\n    result[ 0 ].splice( 1, 0, hash );\r\n  }\r\n\r\n  // attach the attributes to the block\r\n  for ( a in attr ) {\r\n    hash[ a ] = attr[ a ];\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nMarkdown.dialects.Maruku.block.definition_list = function definition_list( block, next ) {\r\n  // one or more terms followed by one or more definitions, in a single block\r\n  var tight = /^((?:[^\\s:].*\\n)+):\\s+([\\s\\S]+)$/,\r\n      list = [ \"dl\" ],\r\n      i, m;\r\n\r\n  // see if we're dealing with a tight or loose block\r\n  if ( ( m = block.match( tight ) ) ) {\r\n    // pull subsequent tight DL blocks out of `next`\r\n    var blocks = [ block ];\r\n    while ( next.length && tight.exec( next[ 0 ] ) ) {\r\n      blocks.push( next.shift() );\r\n    }\r\n\r\n    for ( var b = 0; b < blocks.length; ++b ) {\r\n      var m = blocks[ b ].match( tight ),\r\n          terms = m[ 1 ].replace( /\\n$/, \"\" ).split( /\\n/ ),\r\n          defns = m[ 2 ].split( /\\n:\\s+/ );\r\n\r\n      // print( uneval( m ) );\r\n\r\n      for ( i = 0; i < terms.length; ++i ) {\r\n        list.push( [ \"dt\", terms[ i ] ] );\r\n      }\r\n\r\n      for ( i = 0; i < defns.length; ++i ) {\r\n        // run inline processing over the definition\r\n        list.push( [ \"dd\" ].concat( this.processInline( defns[ i ].replace( /(\\n)\\s+/, \"$1\" ) ) ) );\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    return undefined;\r\n  }\r\n\r\n  return [ list ];\r\n};\r\n\r\n// splits on unescaped instances of @ch. If @ch is not a character the result\r\n// can be unpredictable\r\n\r\nMarkdown.dialects.Maruku.block.table = function table (block, next) {\r\n\r\n    var _split_on_unescaped = function(s, ch) {\r\n        ch = ch || '\\\\s';\r\n        if (ch.match(/^[\\\\|\\[\\]{}?*.+^$]$/)) { ch = '\\\\' + ch; }\r\n        var res = [ ],\r\n            r = new RegExp('^((?:\\\\\\\\.|[^\\\\\\\\' + ch + '])*)' + ch + '(.*)'),\r\n            m;\r\n        while(m = s.match(r)) {\r\n            res.push(m[1]);\r\n            s = m[2];\r\n        }\r\n        res.push(s);\r\n        return res;\r\n    }\r\n\r\n    var leading_pipe = /^ {0,3}\\|(.+)\\n {0,3}\\|\\s*([\\-:]+[\\-| :]*)\\n((?:\\s*\\|.*(?:\\n|$))*)(?=\\n|$)/,\r\n        // find at least an unescaped pipe in each line\r\n        no_leading_pipe = /^ {0,3}(\\S(?:\\\\.|[^\\\\|])*\\|.*)\\n {0,3}([\\-:]+\\s*\\|[\\-| :]*)\\n((?:(?:\\\\.|[^\\\\|])*\\|.*(?:\\n|$))*)(?=\\n|$)/,\r\n        i, m;\r\n    if (m = block.match(leading_pipe)) {\r\n        // remove leading pipes in contents\r\n        // (header and horizontal rule already have the leading pipe left out)\r\n        m[3] = m[3].replace(/^\\s*\\|/gm, '');\r\n    } else if (! ( m = block.match(no_leading_pipe))) {\r\n        return undefined;\r\n    }\r\n\r\n    var table = [ \"table\", [ \"thead\", [ \"tr\" ] ], [ \"tbody\" ] ];\r\n\r\n    // remove trailing pipes, then split on pipes\r\n    // (no escaped pipes are allowed in horizontal rule)\r\n    m[2] = m[2].replace(/\\|\\s*$/, '').split('|');\r\n\r\n    // process alignment\r\n    var html_attrs = [ ];\r\n    forEach (m[2], function (s) {\r\n        if (s.match(/^\\s*-+:\\s*$/))       html_attrs.push({align: \"right\"});\r\n        else if (s.match(/^\\s*:-+\\s*$/))  html_attrs.push({align: \"left\"});\r\n        else if (s.match(/^\\s*:-+:\\s*$/)) html_attrs.push({align: \"center\"});\r\n        else                              html_attrs.push({});\r\n    });\r\n\r\n    // now for the header, avoid escaped pipes\r\n    m[1] = _split_on_unescaped(m[1].replace(/\\|\\s*$/, ''), '|');\r\n    for (i = 0; i < m[1].length; i++) {\r\n        table[1][1].push(['th', html_attrs[i] || {}].concat(\r\n            this.processInline(m[1][i].trim())));\r\n    }\r\n\r\n    // now for body contents\r\n    forEach (m[3].replace(/\\|\\s*$/mg, '').split('\\n'), function (row) {\r\n        var html_row = ['tr'];\r\n        row = _split_on_unescaped(row, '|');\r\n        for (i = 0; i < row.length; i++) {\r\n            html_row.push(['td', html_attrs[i] || {}].concat(this.processInline(row[i].trim())));\r\n        }\r\n        table[2].push(html_row);\r\n    }, this);\r\n\r\n    return [table];\r\n}\r\n\r\nMarkdown.dialects.Maruku.inline[ \"{:\" ] = function inline_meta( text, matches, out ) {\r\n  if ( !out.length ) {\r\n    return [ 2, \"{:\" ];\r\n  }\r\n\r\n  // get the preceeding element\r\n  var before = out[ out.length - 1 ];\r\n\r\n  if ( typeof before === \"string\" ) {\r\n    return [ 2, \"{:\" ];\r\n  }\r\n\r\n  // match a meta hash\r\n  var m = text.match( /^\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}/ );\r\n\r\n  // no match, false alarm\r\n  if ( !m ) {\r\n    return [ 2, \"{:\" ];\r\n  }\r\n\r\n  // attach the attributes to the preceeding element\r\n  var meta = this.dialect.processMetaHash( m[ 1 ] ),\r\n      attr = extract_attr( before );\r\n\r\n  if ( !attr ) {\r\n    attr = {};\r\n    before.splice( 1, 0, attr );\r\n  }\r\n\r\n  for ( var k in meta ) {\r\n    attr[ k ] = meta[ k ];\r\n  }\r\n\r\n  // cut out the string and replace it with nothing\r\n  return [ m[ 0 ].length, \"\" ];\r\n};\r\n\r\nMarkdown.dialects.Maruku.inline.__escape__ = /^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-|:]/;\r\n\r\nMarkdown.buildBlockOrder ( Markdown.dialects.Maruku.block );\r\nMarkdown.buildInlinePatterns( Markdown.dialects.Maruku.inline );\r\n\r\nvar isArray = Array.isArray || function(obj) {\r\n  return Object.prototype.toString.call(obj) == \"[object Array]\";\r\n};\r\n\r\nvar forEach;\r\n// Don't mess with Array.prototype. Its not friendly\r\nif ( Array.prototype.forEach ) {\r\n  forEach = function( arr, cb, thisp ) {\r\n    return arr.forEach( cb, thisp );\r\n  };\r\n}\r\nelse {\r\n  forEach = function(arr, cb, thisp) {\r\n    for (var i = 0; i < arr.length; i++) {\r\n      cb.call(thisp || arr, arr[i], i, arr);\r\n    }\r\n  }\r\n}\r\n\r\nvar isEmpty = function( obj ) {\r\n  for ( var key in obj ) {\r\n    if ( hasOwnProperty.call( obj, key ) ) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction extract_attr( jsonml ) {\r\n  return isArray(jsonml)\r\n      && jsonml.length > 1\r\n      && typeof jsonml[ 1 ] === \"object\"\r\n      && !( isArray(jsonml[ 1 ]) )\r\n      ? jsonml[ 1 ]\r\n      : undefined;\r\n}\r\n\r\n\r\n\r\n/**\r\n *  renderJsonML( jsonml[, options] ) -> String\r\n *  - jsonml (Array): JsonML array to render to XML\r\n *  - options (Object): options\r\n *\r\n *  Converts the given JsonML into well-formed XML.\r\n *\r\n *  The options currently understood are:\r\n *\r\n *  - root (Boolean): wether or not the root node should be included in the\r\n *    output, or just its children. The default `false` is to not include the\r\n *    root itself.\r\n */\r\nexpose.renderJsonML = function( jsonml, options ) {\r\n  options = options || {};\r\n  // include the root element in the rendered output?\r\n  options.root = options.root || false;\r\n\r\n  var content = [];\r\n\r\n  if ( options.root ) {\r\n    content.push( render_tree( jsonml ) );\r\n  }\r\n  else {\r\n    jsonml.shift(); // get rid of the tag\r\n    if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) ) {\r\n      jsonml.shift(); // get rid of the attributes\r\n    }\r\n\r\n    while ( jsonml.length ) {\r\n      content.push( render_tree( jsonml.shift() ) );\r\n    }\r\n  }\r\n\r\n  return content.join( \"\\n\\n\" );\r\n};\r\n\r\nfunction escapeHTML( text ) {\r\n  return text.replace( /&/g, \"&amp;\" )\r\n             .replace( /</g, \"&lt;\" )\r\n             .replace( />/g, \"&gt;\" )\r\n             .replace( /\"/g, \"&quot;\" )\r\n             .replace( /'/g, \"&#39;\" );\r\n}\r\n\r\nfunction render_tree( jsonml ) {\r\n  // basic case\r\n  if ( typeof jsonml === \"string\" ) {\r\n    return escapeHTML( jsonml );\r\n  }\r\n\r\n  var tag = jsonml.shift(),\r\n      attributes = {},\r\n      content = [];\r\n\r\n  if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) ) {\r\n    attributes = jsonml.shift();\r\n  }\r\n\r\n  while ( jsonml.length ) {\r\n    content.push( render_tree( jsonml.shift() ) );\r\n  }\r\n\r\n  var tag_attrs = \"\";\r\n  for ( var a in attributes ) {\r\n    tag_attrs += \" \" + a + '=\"' + escapeHTML( attributes[ a ] ) + '\"';\r\n  }\r\n\r\n  // be careful about adding whitespace here for inline elements\r\n  if ( tag == \"img\" || tag == \"br\" || tag == \"hr\" ) {\r\n    return \"<\"+ tag + tag_attrs + \"/>\";\r\n  }\r\n  else {\r\n    return \"<\"+ tag + tag_attrs + \">\" + content.join( \"\" ) + \"</\" + tag + \">\";\r\n  }\r\n}\r\n\r\nfunction convert_tree_to_html( tree, references, options ) {\r\n  var i;\r\n  options = options || {};\r\n\r\n  // shallow clone\r\n  var jsonml = tree.slice( 0 );\r\n\r\n  if ( typeof options.preprocessTreeNode === \"function\" ) {\r\n      jsonml = options.preprocessTreeNode(jsonml, references);\r\n  }\r\n\r\n  // Clone attributes if they exist\r\n  var attrs = extract_attr( jsonml );\r\n  if ( attrs ) {\r\n    jsonml[ 1 ] = {};\r\n    for ( i in attrs ) {\r\n      jsonml[ 1 ][ i ] = attrs[ i ];\r\n    }\r\n    attrs = jsonml[ 1 ];\r\n  }\r\n\r\n  // basic case\r\n  if ( typeof jsonml === \"string\" ) {\r\n    return jsonml;\r\n  }\r\n\r\n  // convert this node\r\n  switch ( jsonml[ 0 ] ) {\r\n    case \"header\":\r\n      jsonml[ 0 ] = \"h\" + jsonml[ 1 ].level;\r\n      delete jsonml[ 1 ].level;\r\n      break;\r\n    case \"bulletlist\":\r\n      jsonml[ 0 ] = \"ul\";\r\n      break;\r\n    case \"numberlist\":\r\n      jsonml[ 0 ] = \"ol\";\r\n      break;\r\n    case \"listitem\":\r\n      jsonml[ 0 ] = \"li\";\r\n      break;\r\n    case \"para\":\r\n      jsonml[ 0 ] = \"p\";\r\n      break;\r\n    case \"markdown\":\r\n      jsonml[ 0 ] = \"html\";\r\n      if ( attrs ) delete attrs.references;\r\n      break;\r\n    case \"code_block\":\r\n      jsonml[ 0 ] = \"pre\";\r\n      i = attrs ? 2 : 1;\r\n      var code = [ \"code\" ];\r\n      code.push.apply( code, jsonml.splice( i, jsonml.length - i ) );\r\n      jsonml[ i ] = code;\r\n      break;\r\n    case \"inlinecode\":\r\n      jsonml[ 0 ] = \"code\";\r\n      break;\r\n    case \"img\":\r\n      jsonml[ 1 ].src = jsonml[ 1 ].href;\r\n      delete jsonml[ 1 ].href;\r\n      break;\r\n    case \"linebreak\":\r\n      jsonml[ 0 ] = \"br\";\r\n    break;\r\n    case \"link\":\r\n      jsonml[ 0 ] = \"a\";\r\n      break;\r\n    case \"link_ref\":\r\n      jsonml[ 0 ] = \"a\";\r\n\r\n      // grab this ref and clean up the attribute node\r\n      var ref = references[ attrs.ref ];\r\n\r\n      // if the reference exists, make the link\r\n      if ( ref ) {\r\n        delete attrs.ref;\r\n\r\n        // add in the href and title, if present\r\n        attrs.href = ref.href;\r\n        if ( ref.title ) {\r\n          attrs.title = ref.title;\r\n        }\r\n\r\n        // get rid of the unneeded original text\r\n        delete attrs.original;\r\n      }\r\n      // the reference doesn't exist, so revert to plain text\r\n      else {\r\n        return attrs.original;\r\n      }\r\n      break;\r\n    case \"img_ref\":\r\n      jsonml[ 0 ] = \"img\";\r\n\r\n      // grab this ref and clean up the attribute node\r\n      var ref = references[ attrs.ref ];\r\n\r\n      // if the reference exists, make the link\r\n      if ( ref ) {\r\n        delete attrs.ref;\r\n\r\n        // add in the href and title, if present\r\n        attrs.src = ref.href;\r\n        if ( ref.title ) {\r\n          attrs.title = ref.title;\r\n        }\r\n\r\n        // get rid of the unneeded original text\r\n        delete attrs.original;\r\n      }\r\n      // the reference doesn't exist, so revert to plain text\r\n      else {\r\n        return attrs.original;\r\n      }\r\n      break;\r\n  }\r\n\r\n  // convert all the children\r\n  i = 1;\r\n\r\n  // deal with the attribute node, if it exists\r\n  if ( attrs ) {\r\n    // if there are keys, skip over it\r\n    for ( var key in jsonml[ 1 ] ) {\r\n        i = 2;\r\n        break;\r\n    }\r\n    // if there aren't, remove it\r\n    if ( i === 1 ) {\r\n      jsonml.splice( i, 1 );\r\n    }\r\n  }\r\n\r\n  for ( ; i < jsonml.length; ++i ) {\r\n    jsonml[ i ] = convert_tree_to_html( jsonml[ i ], references, options );\r\n  }\r\n\r\n  return jsonml;\r\n}\r\n\r\n\r\n// merges adjacent text nodes into a single node\r\nfunction merge_text_nodes( jsonml ) {\r\n  // skip the tag name and attribute hash\r\n  var i = extract_attr( jsonml ) ? 2 : 1;\r\n\r\n  while ( i < jsonml.length ) {\r\n    // if it's a string check the next item too\r\n    if ( typeof jsonml[ i ] === \"string\" ) {\r\n      if ( i + 1 < jsonml.length && typeof jsonml[ i + 1 ] === \"string\" ) {\r\n        // merge the second string into the first and remove it\r\n        jsonml[ i ] += jsonml.splice( i + 1, 1 )[ 0 ];\r\n      }\r\n      else {\r\n        ++i;\r\n      }\r\n    }\r\n    // if it's not a string recurse\r\n    else {\r\n      merge_text_nodes( jsonml[ i ] );\r\n      ++i;\r\n    }\r\n  }\r\n}\r\n\r\n} )( (function() {\r\n  if ( typeof exports === \"undefined\" ) {\r\n    window.markdown = {};\r\n    return window.markdown;\r\n  }\r\n  else {\r\n    return exports;\r\n  }\r\n} )() );\r\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.toMarkdown = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\r\n/*\r\n * to-markdown - an HTML to Markdown converter\r\n *\r\n * Copyright 2011+, Dom Christie\r\n * Licenced under the MIT licence\r\n *\r\n */\r\n\r\n'use strict'\r\n\r\nvar toMarkdown\r\nvar converters\r\nvar mdConverters = require('./lib/md-converters')\r\nvar gfmConverters = require('./lib/gfm-converters')\r\nvar HtmlParser = require('./lib/html-parser')\r\nvar collapse = require('collapse-whitespace')\r\n\r\n/*\r\n * Utilities\r\n */\r\n\r\nvar blocks = ['address', 'article', 'aside', 'audio', 'blockquote', 'body',\r\n  'canvas', 'center', 'dd', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption',\r\n  'figure', 'footer', 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\r\n  'header', 'hgroup', 'hr', 'html', 'isindex', 'li', 'main', 'menu', 'nav',\r\n  'noframes', 'noscript', 'ol', 'output', 'p', 'pre', 'section', 'table',\r\n  'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'ul'\r\n]\r\n\r\nfunction isBlock (node) {\r\n  return blocks.indexOf(node.nodeName.toLowerCase()) !== -1\r\n}\r\n\r\nvar voids = [\r\n  'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input',\r\n  'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'\r\n]\r\n\r\nfunction isVoid (node) {\r\n  return voids.indexOf(node.nodeName.toLowerCase()) !== -1\r\n}\r\n\r\nfunction htmlToDom (string) {\r\n  var tree = new HtmlParser().parseFromString(string, 'text/html')\r\n  collapse(tree.documentElement, isBlock)\r\n  return tree\r\n}\r\n\r\n/*\r\n * Flattens DOM tree into single array\r\n */\r\n\r\nfunction bfsOrder (node) {\r\n  var inqueue = [node]\r\n  var outqueue = []\r\n  var elem\r\n  var children\r\n  var i\r\n\r\n  while (inqueue.length > 0) {\r\n    elem = inqueue.shift()\r\n    outqueue.push(elem)\r\n    children = elem.childNodes\r\n    for (i = 0; i < children.length; i++) {\r\n      if (children[i].nodeType === 1) inqueue.push(children[i])\r\n    }\r\n  }\r\n  outqueue.shift()\r\n  return outqueue\r\n}\r\n\r\n/*\r\n * Contructs a Markdown string of replacement text for a given node\r\n */\r\n\r\nfunction getContent (node) {\r\n  var text = ''\r\n  for (var i = 0; i < node.childNodes.length; i++) {\r\n    if (node.childNodes[i].nodeType === 1) {\r\n      text += node.childNodes[i]._replacement\r\n    } else if (node.childNodes[i].nodeType === 3) {\r\n      text += node.childNodes[i].data\r\n    } else continue\r\n  }\r\n  return text\r\n}\r\n\r\n/*\r\n * Returns the HTML string of an element with its contents converted\r\n */\r\n\r\nfunction outer (node, content) {\r\n  return node.cloneNode(false).outerHTML.replace('><', '>' + content + '<')\r\n}\r\n\r\nfunction canConvert (node, filter) {\r\n  if (typeof filter === 'string') {\r\n    return filter === node.nodeName.toLowerCase()\r\n  }\r\n  if (Array.isArray(filter)) {\r\n    return filter.indexOf(node.nodeName.toLowerCase()) !== -1\r\n  } else if (typeof filter === 'function') {\r\n    return filter.call(toMarkdown, node)\r\n  } else {\r\n    throw new TypeError('`filter` needs to be a string, array, or function')\r\n  }\r\n}\r\n\r\nfunction isFlankedByWhitespace (side, node) {\r\n  var sibling\r\n  var regExp\r\n  var isFlanked\r\n\r\n  if (side === 'left') {\r\n    sibling = node.previousSibling\r\n    regExp = / $/\r\n  } else {\r\n    sibling = node.nextSibling\r\n    regExp = /^ /\r\n  }\r\n\r\n  if (sibling) {\r\n    if (sibling.nodeType === 3) {\r\n      isFlanked = regExp.test(sibling.nodeValue)\r\n    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {\r\n      isFlanked = regExp.test(sibling.textContent)\r\n    }\r\n  }\r\n  return isFlanked\r\n}\r\n\r\nfunction flankingWhitespace (node) {\r\n  var leading = ''\r\n  var trailing = ''\r\n\r\n  if (!isBlock(node)) {\r\n    var hasLeading = /^[ \\r\\n\\t]/.test(node.innerHTML)\r\n    var hasTrailing = /[ \\r\\n\\t]$/.test(node.innerHTML)\r\n\r\n    if (hasLeading && !isFlankedByWhitespace('left', node)) {\r\n      leading = ' '\r\n    }\r\n    if (hasTrailing && !isFlankedByWhitespace('right', node)) {\r\n      trailing = ' '\r\n    }\r\n  }\r\n\r\n  return { leading: leading, trailing: trailing }\r\n}\r\n\r\n/*\r\n * Finds a Markdown converter, gets the replacement, and sets it on\r\n * `_replacement`\r\n */\r\n\r\nfunction process (node) {\r\n  var replacement\r\n  var content = getContent(node)\r\n\r\n  // Remove blank nodes\r\n  if (!isVoid(node) && !/A|TH|TD/.test(node.nodeName) && /^\\s*$/i.test(content)) {\r\n    node._replacement = ''\r\n    return\r\n  }\r\n\r\n  for (var i = 0; i < converters.length; i++) {\r\n    var converter = converters[i]\r\n\r\n    if (canConvert(node, converter.filter)) {\r\n      if (typeof converter.replacement !== 'function') {\r\n        throw new TypeError(\r\n          '`replacement` needs to be a function that returns a string'\r\n        )\r\n      }\r\n\r\n      var whitespace = flankingWhitespace(node)\r\n\r\n      if (whitespace.leading || whitespace.trailing) {\r\n        content = content.trim()\r\n      }\r\n      replacement = whitespace.leading +\r\n        converter.replacement.call(toMarkdown, content, node) +\r\n        whitespace.trailing\r\n      break\r\n    }\r\n  }\r\n\r\n  node._replacement = replacement\r\n}\r\n\r\ntoMarkdown = function (input, options) {\r\n  options = options || {}\r\n\r\n  if (typeof input !== 'string') {\r\n    throw new TypeError(input + ' is not a string')\r\n  }\r\n\r\n  // Escape potential ol triggers\r\n  input = input.replace(/(\\d+)\\. /g, '$1\\\\. ')\r\n\r\n  var clone = htmlToDom(input).body\r\n  var nodes = bfsOrder(clone)\r\n  var output\r\n\r\n  converters = mdConverters.slice(0)\r\n  if (options.gfm) {\r\n    converters = gfmConverters.concat(converters)\r\n  }\r\n\r\n  if (options.converters) {\r\n    converters = options.converters.concat(converters)\r\n  }\r\n\r\n  // Process through nodes in reverse (so deepest child elements are first).\r\n  for (var i = nodes.length - 1; i >= 0; i--) {\r\n    process(nodes[i])\r\n  }\r\n  output = getContent(clone)\r\n\r\n  return output.replace(/^[\\t\\r\\n]+|[\\t\\r\\n\\s]+$/g, '')\r\n    .replace(/\\n\\s+\\n/g, '\\n\\n')\r\n    .replace(/\\n{3,}/g, '\\n\\n')\r\n}\r\n\r\ntoMarkdown.isBlock = isBlock\r\ntoMarkdown.isVoid = isVoid\r\ntoMarkdown.outer = outer\r\n\r\nmodule.exports = toMarkdown\r\n\r\n},{\"./lib/gfm-converters\":2,\"./lib/html-parser\":3,\"./lib/md-converters\":4,\"collapse-whitespace\":7}],2:[function(require,module,exports){\r\n'use strict'\r\n\r\nfunction cell (content, node) {\r\n  var index = Array.prototype.indexOf.call(node.parentNode.childNodes, node)\r\n  var prefix = ' '\r\n  if (index === 0) prefix = '| '\r\n  return prefix + content + ' |'\r\n}\r\n\r\nvar highlightRegEx = /highlight highlight-(\\S+)/\r\n\r\nmodule.exports = [\r\n  {\r\n    filter: 'br',\r\n    replacement: function () {\r\n      return '\\n'\r\n    }\r\n  },\r\n  {\r\n    filter: ['del', 's', 'strike'],\r\n    replacement: function (content) {\r\n      return '~~' + content + '~~'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: function (node) {\r\n      return node.type === 'checkbox' && node.parentNode.nodeName === 'LI'\r\n    },\r\n    replacement: function (content, node) {\r\n      return (node.checked ? '[x]' : '[ ]') + ' '\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: ['th', 'td'],\r\n    replacement: function (content, node) {\r\n      return cell(content, node)\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: 'tr',\r\n    replacement: function (content, node) {\r\n      var borderCells = ''\r\n      var alignMap = { left: ':--', right: '--:', center: ':-:' }\r\n\r\n      if (node.parentNode.nodeName === 'THEAD') {\r\n        for (var i = 0; i < node.childNodes.length; i++) {\r\n          var align = node.childNodes[i].attributes.align\r\n          var border = '---'\r\n\r\n          if (align) border = alignMap[align.value] || border\r\n\r\n          borderCells += cell(border, node.childNodes[i])\r\n        }\r\n      }\r\n      return '\\n' + content + (borderCells ? '\\n' + borderCells : '')\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: 'table',\r\n    replacement: function (content) {\r\n      return '\\n\\n' + content + '\\n\\n'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: ['thead', 'tbody', 'tfoot'],\r\n    replacement: function (content) {\r\n      return content\r\n    }\r\n  },\r\n\r\n  // Fenced code blocks\r\n  {\r\n    filter: function (node) {\r\n      return node.nodeName === 'PRE' &&\r\n      node.firstChild &&\r\n      node.firstChild.nodeName === 'CODE'\r\n    },\r\n    replacement: function (content, node) {\r\n      return '\\n\\n```\\n' + node.firstChild.textContent + '\\n```\\n\\n'\r\n    }\r\n  },\r\n\r\n  // Syntax-highlighted code blocks\r\n  {\r\n    filter: function (node) {\r\n      return node.nodeName === 'PRE' &&\r\n      node.parentNode.nodeName === 'DIV' &&\r\n      highlightRegEx.test(node.parentNode.className)\r\n    },\r\n    replacement: function (content, node) {\r\n      var language = node.parentNode.className.match(highlightRegEx)[1]\r\n      return '\\n\\n```' + language + '\\n' + node.textContent + '\\n```\\n\\n'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: function (node) {\r\n      return node.nodeName === 'DIV' &&\r\n      highlightRegEx.test(node.className)\r\n    },\r\n    replacement: function (content) {\r\n      return '\\n\\n' + content + '\\n\\n'\r\n    }\r\n  }\r\n]\r\n\r\n},{}],3:[function(require,module,exports){\r\n/*\r\n * Set up window for Node.js\r\n */\r\n\r\nvar _window = (typeof window !== 'undefined' ? window : this)\r\n\r\n/*\r\n * Parsing HTML strings\r\n */\r\n\r\nfunction canParseHtmlNatively () {\r\n  var Parser = _window.DOMParser\r\n  var canParse = false\r\n\r\n  // Adapted from https://gist.github.com/1129031\r\n  // Firefox/Opera/IE throw errors on unsupported types\r\n  try {\r\n    // WebKit returns null on unsupported types\r\n    if (new Parser().parseFromString('', 'text/html')) {\r\n      canParse = true\r\n    }\r\n  } catch (e) {}\r\n\r\n  return canParse\r\n}\r\n\r\nfunction createHtmlParser () {\r\n  var Parser = function () {}\r\n\r\n  // For Node.js environments\r\n  if (typeof document === 'undefined') {\r\n    var jsdom = require('jsdom')\r\n    Parser.prototype.parseFromString = function (string) {\r\n      return jsdom.jsdom(string, {\r\n        features: {\r\n          FetchExternalResources: [],\r\n          ProcessExternalResources: false\r\n        }\r\n      })\r\n    }\r\n  } else {\r\n    if (!shouldUseActiveX()) {\r\n      Parser.prototype.parseFromString = function (string) {\r\n        var doc = document.implementation.createHTMLDocument('')\r\n        doc.open()\r\n        doc.write(string)\r\n        doc.close()\r\n        return doc\r\n      }\r\n    } else {\r\n      Parser.prototype.parseFromString = function (string) {\r\n        var doc = new window.ActiveXObject('htmlfile')\r\n        doc.designMode = 'on' // disable on-page scripts\r\n        doc.open()\r\n        doc.write(string)\r\n        doc.close()\r\n        return doc\r\n      }\r\n    }\r\n  }\r\n  return Parser\r\n}\r\n\r\nfunction shouldUseActiveX () {\r\n  var useActiveX = false\r\n\r\n  try {\r\n    document.implementation.createHTMLDocument('').open()\r\n  } catch (e) {\r\n    if (window.ActiveXObject) useActiveX = true\r\n  }\r\n\r\n  return useActiveX\r\n}\r\n\r\nmodule.exports = canParseHtmlNatively() ? _window.DOMParser : createHtmlParser()\r\n\r\n},{\"jsdom\":6}],4:[function(require,module,exports){\r\n'use strict'\r\n\r\nmodule.exports = [\r\n  {\r\n    filter: 'p',\r\n    replacement: function (content) {\r\n      return '\\n\\n' + content + '\\n\\n'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: 'br',\r\n    replacement: function () {\r\n      return '  \\n'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\r\n    replacement: function (content, node) {\r\n      var hLevel = node.nodeName.charAt(1)\r\n      var hPrefix = ''\r\n      for (var i = 0; i < hLevel; i++) {\r\n        hPrefix += '#'\r\n      }\r\n      return '\\n\\n' + hPrefix + ' ' + content + '\\n\\n'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: 'hr',\r\n    replacement: function () {\r\n      return '\\n\\n* * *\\n\\n'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: ['em', 'i'],\r\n    replacement: function (content) {\r\n      return '_' + content + '_'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: ['strong', 'b'],\r\n    replacement: function (content) {\r\n      return '**' + content + '**'\r\n    }\r\n  },\r\n\r\n  // Inline code\r\n  {\r\n    filter: function (node) {\r\n      var hasSiblings = node.previousSibling || node.nextSibling\r\n      var isCodeBlock = node.parentNode.nodeName === 'PRE' && !hasSiblings\r\n\r\n      return node.nodeName === 'CODE' && !isCodeBlock\r\n    },\r\n    replacement: function (content) {\r\n      return '`' + content + '`'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: function (node) {\r\n      return node.nodeName === 'A' && node.getAttribute('href')\r\n    },\r\n    replacement: function (content, node) {\r\n      var titlePart = node.title ? ' \"' + node.title + '\"' : ''\r\n      return '[' + content + '](' + node.getAttribute('href') + titlePart + ')'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: 'img',\r\n    replacement: function (content, node) {\r\n      var alt = node.alt || ''\r\n      var src = node.getAttribute('src') || ''\r\n      var title = node.title || ''\r\n      var titlePart = title ? ' \"' + title + '\"' : ''\r\n      return src ? '![' + alt + ']' + '(' + src + titlePart + ')' : ''\r\n    }\r\n  },\r\n\r\n  // Code blocks\r\n  {\r\n    filter: function (node) {\r\n      return node.nodeName === 'PRE' && node.firstChild.nodeName === 'CODE'\r\n    },\r\n    replacement: function (content, node) {\r\n      return '\\n\\n    ' + node.firstChild.textContent.replace(/\\n/g, '\\n    ') + '\\n\\n'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: 'blockquote',\r\n    replacement: function (content) {\r\n      content = content.trim()\r\n      content = content.replace(/\\n{3,}/g, '\\n\\n')\r\n      content = content.replace(/^/gm, '> ')\r\n      return '\\n\\n' + content + '\\n\\n'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: 'li',\r\n    replacement: function (content, node) {\r\n      content = content.replace(/^\\s+/, '').replace(/\\n/gm, '\\n    ')\r\n      var prefix = '*   '\r\n      var parent = node.parentNode\r\n      var index = Array.prototype.indexOf.call(parent.children, node) + 1\r\n\r\n      prefix = /ol/i.test(parent.nodeName) ? index + '.  ' : '*   '\r\n      return prefix + content\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: ['ul', 'ol'],\r\n    replacement: function (content, node) {\r\n      var strings = []\r\n      for (var i = 0; i < node.childNodes.length; i++) {\r\n        strings.push(node.childNodes[i]._replacement)\r\n      }\r\n\r\n      if (/li/i.test(node.parentNode.nodeName)) {\r\n        return '\\n' + strings.join('\\n')\r\n      }\r\n      return '\\n\\n' + strings.join('\\n') + '\\n\\n'\r\n    }\r\n  },\r\n\r\n  {\r\n    filter: function (node) {\r\n      return this.isBlock(node)\r\n    },\r\n    replacement: function (content, node) {\r\n      return '\\n\\n' + this.outer(node, content) + '\\n\\n'\r\n    }\r\n  },\r\n\r\n  // Anything else!\r\n  {\r\n    filter: function () {\r\n      return true\r\n    },\r\n    replacement: function (content, node) {\r\n      return this.outer(node, content)\r\n    }\r\n  }\r\n]\r\n\r\n},{}],5:[function(require,module,exports){\r\n/**\r\n * This file automatically generated from `build.js`.\r\n * Do not manually edit.\r\n */\r\n\r\nmodule.exports = [\r\n  \"address\",\r\n  \"article\",\r\n  \"aside\",\r\n  \"audio\",\r\n  \"blockquote\",\r\n  \"canvas\",\r\n  \"dd\",\r\n  \"div\",\r\n  \"dl\",\r\n  \"fieldset\",\r\n  \"figcaption\",\r\n  \"figure\",\r\n  \"footer\",\r\n  \"form\",\r\n  \"h1\",\r\n  \"h2\",\r\n  \"h3\",\r\n  \"h4\",\r\n  \"h5\",\r\n  \"h6\",\r\n  \"header\",\r\n  \"hgroup\",\r\n  \"hr\",\r\n  \"main\",\r\n  \"nav\",\r\n  \"noscript\",\r\n  \"ol\",\r\n  \"output\",\r\n  \"p\",\r\n  \"pre\",\r\n  \"section\",\r\n  \"table\",\r\n  \"tfoot\",\r\n  \"ul\",\r\n  \"video\"\r\n];\r\n\r\n},{}],6:[function(require,module,exports){\r\n\r\n},{}],7:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar voidElements = require('void-elements');\r\nObject.keys(voidElements).forEach(function (name) {\r\n  voidElements[name.toUpperCase()] = 1;\r\n});\r\n\r\nvar blockElements = {};\r\nrequire('block-elements').forEach(function (name) {\r\n  blockElements[name.toUpperCase()] = 1;\r\n});\r\n\r\n/**\r\n * isBlockElem(node) determines if the given node is a block element.\r\n *\r\n * @param {Node} node\r\n * @return {Boolean}\r\n */\r\nfunction isBlockElem(node) {\r\n  return !!(node && blockElements[node.nodeName]);\r\n}\r\n\r\n/**\r\n * isVoid(node) determines if the given node is a void element.\r\n *\r\n * @param {Node} node\r\n * @return {Boolean}\r\n */\r\nfunction isVoid(node) {\r\n  return !!(node && voidElements[node.nodeName]);\r\n}\r\n\r\n/**\r\n * whitespace(elem [, isBlock]) removes extraneous whitespace from an\r\n * the given element. The function isBlock may optionally be passed in\r\n * to determine whether or not an element is a block element; if none\r\n * is provided, defaults to using the list of block elements provided\r\n * by the `block-elements` module.\r\n *\r\n * @param {Node} elem\r\n * @param {Function} blockTest\r\n */\r\nfunction collapseWhitespace(elem, isBlock) {\r\n  if (!elem.firstChild || elem.nodeName === 'PRE') return;\r\n\r\n  if (typeof isBlock !== 'function') {\r\n    isBlock = isBlockElem;\r\n  }\r\n\r\n  var prevText = null;\r\n  var prevVoid = false;\r\n\r\n  var prev = null;\r\n  var node = next(prev, elem);\r\n\r\n  while (node !== elem) {\r\n    if (node.nodeType === 3) {\r\n      // Node.TEXT_NODE\r\n      var text = node.data.replace(/[ \\r\\n\\t]+/g, ' ');\r\n\r\n      if ((!prevText || / $/.test(prevText.data)) && !prevVoid && text[0] === ' ') {\r\n        text = text.substr(1);\r\n      }\r\n\r\n      // `text` might be empty at this point.\r\n      if (!text) {\r\n        node = remove(node);\r\n        continue;\r\n      }\r\n\r\n      node.data = text;\r\n      prevText = node;\r\n    } else if (node.nodeType === 1) {\r\n      // Node.ELEMENT_NODE\r\n      if (isBlock(node) || node.nodeName === 'BR') {\r\n        if (prevText) {\r\n          prevText.data = prevText.data.replace(/ $/, '');\r\n        }\r\n\r\n        prevText = null;\r\n        prevVoid = false;\r\n      } else if (isVoid(node)) {\r\n        // Avoid trimming space around non-block, non-BR void elements.\r\n        prevText = null;\r\n        prevVoid = true;\r\n      }\r\n    } else {\r\n      node = remove(node);\r\n      continue;\r\n    }\r\n\r\n    var nextNode = next(prev, node);\r\n    prev = node;\r\n    node = nextNode;\r\n  }\r\n\r\n  if (prevText) {\r\n    prevText.data = prevText.data.replace(/ $/, '');\r\n    if (!prevText.data) {\r\n      remove(prevText);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * remove(node) removes the given node from the DOM and returns the\r\n * next node in the sequence.\r\n *\r\n * @param {Node} node\r\n * @return {Node} node\r\n */\r\nfunction remove(node) {\r\n  var next = node.nextSibling || node.parentNode;\r\n\r\n  node.parentNode.removeChild(node);\r\n\r\n  return next;\r\n}\r\n\r\n/**\r\n * next(prev, current) returns the next node in the sequence, given the\r\n * current and previous nodes.\r\n *\r\n * @param {Node} prev\r\n * @param {Node} current\r\n * @return {Node}\r\n */\r\nfunction next(prev, current) {\r\n  if (prev && prev.parentNode === current || current.nodeName === 'PRE') {\r\n    return current.nextSibling || current.parentNode;\r\n  }\r\n\r\n  return current.firstChild || current.nextSibling || current.parentNode;\r\n}\r\n\r\nmodule.exports = collapseWhitespace;\r\n\r\n},{\"block-elements\":5,\"void-elements\":8}],8:[function(require,module,exports){\r\n/**\r\n * This file automatically generated from `pre-publish.js`.\r\n * Do not manually edit.\r\n */\r\n\r\nmodule.exports = {\r\n  \"area\": true,\r\n  \"base\": true,\r\n  \"br\": true,\r\n  \"col\": true,\r\n  \"embed\": true,\r\n  \"hr\": true,\r\n  \"img\": true,\r\n  \"input\": true,\r\n  \"keygen\": true,\r\n  \"link\": true,\r\n  \"menuitem\": true,\r\n  \"meta\": true,\r\n  \"param\": true,\r\n  \"source\": true,\r\n  \"track\": true,\r\n  \"wbr\": true\r\n};\r\n\r\n},{}]},{},[1])(1)\r\n});","/* ===================================================\r\n * bootstrap-markdown.js v2.10.0\r\n * http://github.com/toopay/bootstrap-markdown\r\n * ===================================================\r\n * Copyright 2013-2016 Taufan Aditya\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ========================================================== */\r\n\r\n(function(factory){\r\n    if (typeof define === \"function\" && define.amd) {\r\n        //RequireJS\r\n        define([\"jquery\"], factory);\r\n    } else if (typeof exports === 'object') {\r\n        //Backbone.js\r\n        factory(require('jquery'));\r\n    } else {\r\n        //Jquery plugin\r\n        factory(jQuery);\r\n    }\r\n}(function($){\r\n  \"use strict\"; // jshint ;_;\r\n\r\n  /* MARKDOWN CLASS DEFINITION\r\n   * ========================== */\r\n\r\n  var Markdown = function (element, options) {\r\n    // @TODO : remove this BC on next major release\r\n    // @see : https://github.com/toopay/bootstrap-markdown/issues/109\r\n    var opts = ['autofocus', 'savable', 'hideable', 'width', \r\n      'height', 'resize', 'iconlibrary', 'language', \r\n      'footer', 'fullscreen', 'hiddenButtons', 'disabledButtons'];\r\n    $.each(opts,function(_, opt){\r\n      if (typeof $(element).data(opt) !== 'undefined') {\r\n        options = typeof options == 'object' ? options : {}\r\n        options[opt] = $(element).data(opt)\r\n      }\r\n    });\r\n    // End BC\r\n\r\n    // Class Properties\r\n    this.$ns           = 'bootstrap-markdown';\r\n    this.$element      = $(element);\r\n    this.$editable     = {el:null, type:null,attrKeys:[], attrValues:[], content:null};\r\n    this.$options      = $.extend(true, {}, $.fn.markdown.defaults, options, this.$element.data('options'));\r\n    this.$oldContent   = null;\r\n    this.$isPreview    = false;\r\n    this.$isFullscreen = false;\r\n    this.$editor       = null;\r\n    this.$textarea     = null;\r\n    this.$handler      = [];\r\n    this.$callback     = [];\r\n    this.$nextTab      = [];\r\n\r\n    this.showEditor();\r\n  };\r\n\r\n  Markdown.prototype = {\r\n\r\n    constructor: Markdown\r\n\r\n  , __alterButtons: function(name,alter) {\r\n      var handler = this.$handler, isAll = (name == 'all'),that = this;\r\n\r\n      $.each(handler,function(k,v) {\r\n        var halt = true;\r\n        if (isAll) {\r\n          halt = false;\r\n        } else {\r\n          halt = v.indexOf(name) < 0;\r\n        }\r\n\r\n        if (halt === false) {\r\n          alter(that.$editor.find('button[data-handler=\"'+v+'\"]'));\r\n        }\r\n      });\r\n    }\r\n\r\n  , __buildButtons: function(buttonsArray, container) {\r\n      var i,\r\n          ns = this.$ns,\r\n          handler = this.$handler,\r\n          callback = this.$callback;\r\n\r\n      for (i=0;i<buttonsArray.length;i++) {\r\n        // Build each group container\r\n        var y, btnGroups = buttonsArray[i];\r\n        for (y=0;y<btnGroups.length;y++) {\r\n          // Build each button group\r\n          var z,\r\n              buttons = btnGroups[y].data,\r\n              btnGroupContainer = $('<div/>', {\r\n                                    'class': 'btn-group'\r\n                                  });\r\n\r\n          for (z=0;z<buttons.length;z++) {\r\n            var button = buttons[z],\r\n                buttonContainer, buttonIconContainer,\r\n                buttonHandler = ns+'-'+button.name,\r\n                buttonIcon = this.__getIcon(button.icon),\r\n                btnText = button.btnText ? button.btnText : '',\r\n                btnClass = button.btnClass ? button.btnClass : 'btn',\r\n                tabIndex = button.tabIndex ? button.tabIndex : '-1',\r\n                hotkey = typeof button.hotkey !== 'undefined' ? button.hotkey : '',\r\n                hotkeyCaption = typeof jQuery.hotkeys !== 'undefined' && hotkey !== '' ? ' ('+hotkey+')' : '';\r\n\r\n            // Construct the button object\r\n            buttonContainer = $('<button></button>');\r\n            buttonContainer.text(' ' + this.__localize(btnText)).addClass('btn-default btn-sm').addClass(btnClass);\r\n            if(btnClass.match(/btn\\-(primary|success|info|warning|danger|link)/)){\r\n                buttonContainer.removeClass('btn-default');\r\n            }\r\n            buttonContainer.attr({\r\n                'type': 'button',\r\n                'title': this.__localize(button.title) + hotkeyCaption,\r\n                'tabindex': tabIndex,\r\n                'data-provider': ns,\r\n                'data-handler': buttonHandler,\r\n                'data-hotkey': hotkey\r\n            });\r\n            if (button.toggle === true){\r\n              buttonContainer.attr('data-toggle', 'button');\r\n            }\r\n            buttonIconContainer = $('<span/>');\r\n            buttonIconContainer.addClass(buttonIcon);\r\n            buttonIconContainer.prependTo(buttonContainer);\r\n\r\n            // Attach the button object\r\n            btnGroupContainer.append(buttonContainer);\r\n\r\n            // Register handler and callback\r\n            handler.push(buttonHandler);\r\n            callback.push(button.callback);\r\n          }\r\n\r\n          // Attach the button group into container dom\r\n          container.append(btnGroupContainer);\r\n        }\r\n      }\r\n\r\n      return container;\r\n    }\r\n  , __setListener: function() {\r\n      // Set size and resizable Properties\r\n      var hasRows = typeof this.$textarea.attr('rows') !== 'undefined',\r\n          maxRows = this.$textarea.val().split(\"\\n\").length > 5 ? this.$textarea.val().split(\"\\n\").length : '5',\r\n          rowsVal = hasRows ? this.$textarea.attr('rows') : maxRows;\r\n\r\n      this.$textarea.attr('rows',rowsVal);\r\n      if (this.$options.resize) {\r\n        this.$textarea.css('resize',this.$options.resize);\r\n      }\r\n\r\n      this.$textarea.on({\r\n          'focus' : $.proxy(this.focus, this),\r\n          'keyup' : $.proxy(this.keyup, this),\r\n          'change' : $.proxy(this.change, this),\r\n          'select' : $.proxy(this.select, this)\r\n      });\r\n\r\n      if (this.eventSupported('keydown')) {\r\n        this.$textarea.on('keydown', $.proxy(this.keydown, this));\r\n      }\r\n\r\n      if (this.eventSupported('keypress')) {\r\n        this.$textarea.on('keypress', $.proxy(this.keypress, this))\r\n      }\r\n\r\n      // Re-attach markdown data\r\n      this.$textarea.data('markdown',this);\r\n    }\r\n\r\n  , __handle: function(e) {\r\n      var target = $(e.currentTarget),\r\n          handler = this.$handler,\r\n          callback = this.$callback,\r\n          handlerName = target.attr('data-handler'),\r\n          callbackIndex = handler.indexOf(handlerName),\r\n          callbackHandler = callback[callbackIndex];\r\n\r\n      // Trigger the focusin\r\n      $(e.currentTarget).focus();\r\n\r\n      callbackHandler(this);\r\n\r\n      // Trigger onChange for each button handle\r\n      this.change(this);\r\n\r\n      // Unless it was the save handler,\r\n      // focusin the textarea\r\n      if (handlerName.indexOf('cmdSave') < 0) {\r\n        this.$textarea.focus();\r\n      }\r\n\r\n      e.preventDefault();\r\n    }\r\n\r\n  , __localize: function(string) {\r\n      var messages = $.fn.markdown.messages,\r\n          language = this.$options.language;\r\n      if (\r\n        typeof messages !== 'undefined' &&\r\n        typeof messages[language] !== 'undefined' &&\r\n        typeof messages[language][string] !== 'undefined'\r\n      ) {\r\n        return messages[language][string];\r\n      }\r\n      return string;\r\n    }\r\n\r\n  , __getIcon: function(src) {\r\n    return typeof src == 'object' ? src[this.$options.iconlibrary] : src;\r\n  }\r\n\r\n  , setFullscreen: function(mode) {\r\n    var $editor = this.$editor,\r\n        $textarea = this.$textarea;\r\n\r\n    if (mode === true) {\r\n      $editor.addClass('md-fullscreen-mode');\r\n      $('body').addClass('md-nooverflow');\r\n      this.$options.onFullscreen(this);\r\n    } else {\r\n      $editor.removeClass('md-fullscreen-mode');\r\n      $('body').removeClass('md-nooverflow');\r\n\r\n      if (this.$isPreview == true) this.hidePreview().showPreview()\r\n    }\r\n\r\n    this.$isFullscreen = mode;\r\n    $textarea.focus();\r\n  }\r\n\r\n  , showEditor: function() {\r\n      var instance = this,\r\n          textarea,\r\n          ns = this.$ns,\r\n          container = this.$element,\r\n          originalHeigth = container.css('height'),\r\n          originalWidth = container.css('width'),\r\n          editable = this.$editable,\r\n          handler = this.$handler,\r\n          callback = this.$callback,\r\n          options = this.$options,\r\n          editor = $( '<div/>', {\r\n                      'class': 'md-editor',\r\n                      click: function() {\r\n                        instance.focus();\r\n                      }\r\n                    });\r\n\r\n      // Prepare the editor\r\n      if (this.$editor === null) {\r\n        // Create the panel\r\n        var editorHeader = $('<div/>', {\r\n                            'class': 'md-header btn-toolbar'\r\n                            });\r\n\r\n        // Merge the main & additional button groups together\r\n        var allBtnGroups = [];\r\n        if (options.buttons.length > 0) allBtnGroups = allBtnGroups.concat(options.buttons[0]);\r\n        if (options.additionalButtons.length > 0) {\r\n          // iterate the additional button groups\r\n          $.each(options.additionalButtons[0], function(idx, buttonGroup){\r\n            \r\n            // see if the group name of the addional group matches an existing group\r\n            var matchingGroups = $.grep(allBtnGroups, function(allButtonGroup, allIdx){\r\n              return allButtonGroup.name === buttonGroup.name;\r\n            });\r\n\r\n            // if it matches add the addional buttons to that group, if not just add it to the all buttons group\r\n            if(matchingGroups.length > 0) {\r\n              matchingGroups[0].data = matchingGroups[0].data.concat(buttonGroup.data);\r\n            } else {              \r\n              allBtnGroups.push(options.additionalButtons[0][idx]);\r\n            }\r\n\r\n          });\r\n        } \r\n\r\n        // Reduce and/or reorder the button groups\r\n        if (options.reorderButtonGroups.length > 0) {\r\n          allBtnGroups = allBtnGroups\r\n              .filter(function(btnGroup) {\r\n                return options.reorderButtonGroups.indexOf(btnGroup.name) > -1;\r\n              })\r\n              .sort(function(a, b) {\r\n                if (options.reorderButtonGroups.indexOf(a.name) < options.reorderButtonGroups.indexOf(b.name)) return -1;\r\n                if (options.reorderButtonGroups.indexOf(a.name) > options.reorderButtonGroups.indexOf(b.name)) return 1;\r\n                return 0;\r\n              });\r\n        }\r\n\r\n        // Build the buttons\r\n        if (allBtnGroups.length > 0) {\r\n          editorHeader = this.__buildButtons([allBtnGroups], editorHeader);\r\n        }\r\n\r\n        if (options.fullscreen.enable) {\r\n          editorHeader.append('<div class=\"md-controls\"><a class=\"md-control md-control-fullscreen\" href=\"#\"><span class=\"'+this.__getIcon(options.fullscreen.icons.fullscreenOn)+'\"></span></a></div>').on('click', '.md-control-fullscreen', function(e) {\r\n              e.preventDefault();\r\n              instance.setFullscreen(true);\r\n          });\r\n        }\r\n\r\n        editor.append(editorHeader);\r\n\r\n        // Wrap the textarea\r\n        if (container.is('textarea')) {\r\n          container.before(editor);\r\n          textarea = container;\r\n          textarea.addClass('md-input');\r\n          editor.append(textarea);\r\n        } else {\r\n          var rawContent = (typeof toMarkdown == 'function') ? toMarkdown(container.html()) : container.html(),\r\n              currentContent = $.trim(rawContent);\r\n\r\n          // This is some arbitrary content that could be edited\r\n          textarea = $('<textarea/>', {\r\n                       'class': 'md-input',\r\n                       'val' : currentContent\r\n                      });\r\n\r\n          editor.append(textarea);\r\n\r\n          // Save the editable\r\n          editable.el = container;\r\n          editable.type = container.prop('tagName').toLowerCase();\r\n          editable.content = container.html();\r\n\r\n          $(container[0].attributes).each(function(){\r\n            editable.attrKeys.push(this.nodeName);\r\n            editable.attrValues.push(this.nodeValue);\r\n          });\r\n\r\n          // Set editor to blocked the original container\r\n          container.replaceWith(editor);\r\n        }\r\n\r\n        var editorFooter = $('<div/>', {\r\n                           'class': 'md-footer'\r\n                         }),\r\n            createFooter = false,\r\n            footer = '';\r\n        // Create the footer if savable\r\n        if (options.savable) {\r\n          createFooter = true;\r\n          var saveHandler = 'cmdSave';\r\n\r\n          // Register handler and callback\r\n          handler.push(saveHandler);\r\n          callback.push(options.onSave);\r\n\r\n          editorFooter.append('<button class=\"btn btn-success\" data-provider=\"'\r\n                              + ns\r\n                              + '\" data-handler=\"'\r\n                              + saveHandler\r\n                              + '\"><i class=\"icon icon-white icon-ok\"></i> '\r\n                              + this.__localize('Save')\r\n                              + '</button>');\r\n\r\n\r\n        }\r\n\r\n        footer = typeof options.footer === 'function' ? options.footer(this) : options.footer;\r\n\r\n        if ($.trim(footer) !== '') {\r\n          createFooter = true;\r\n          editorFooter.append(footer);\r\n        }\r\n\r\n        if (createFooter) editor.append(editorFooter);\r\n\r\n        // Set width\r\n        if (options.width && options.width !== 'inherit') {\r\n          if (jQuery.isNumeric(options.width)) {\r\n            editor.css('display', 'table');\r\n            textarea.css('width', options.width + 'px');\r\n          } else {\r\n            editor.addClass(options.width);\r\n          }\r\n        }\r\n\r\n        // Set height\r\n        if (options.height && options.height !== 'inherit') {\r\n          if (jQuery.isNumeric(options.height)) {\r\n            var height = options.height;\r\n            if (editorHeader) height = Math.max(0, height - editorHeader.outerHeight());\r\n            if (editorFooter) height = Math.max(0, height - editorFooter.outerHeight());\r\n            textarea.css('height', height + 'px');\r\n          } else {\r\n            editor.addClass(options.height);\r\n          }\r\n        }\r\n\r\n        // Reference\r\n        this.$editor     = editor;\r\n        this.$textarea   = textarea;\r\n        this.$editable   = editable;\r\n        this.$oldContent = this.getContent();\r\n\r\n        this.__setListener();\r\n\r\n        // Set editor attributes, data short-hand API and listener\r\n        this.$editor.attr('id',(new Date()).getTime());\r\n        this.$editor.on('click', '[data-provider=\"bootstrap-markdown\"]', $.proxy(this.__handle, this));\r\n\r\n        if (this.$element.is(':disabled') || this.$element.is('[readonly]')) {\r\n          this.$editor.addClass('md-editor-disabled');\r\n          this.disableButtons('all');\r\n        }\r\n\r\n        if (this.eventSupported('keydown') && typeof jQuery.hotkeys === 'object') {\r\n          editorHeader.find('[data-provider=\"bootstrap-markdown\"]').each(function() {\r\n            var $button = $(this),\r\n                hotkey = $button.attr('data-hotkey');\r\n            if (hotkey.toLowerCase() !== '') {\r\n              textarea.bind('keydown', hotkey, function() {\r\n                $button.trigger('click');\r\n                return false;\r\n              });\r\n            }\r\n          });\r\n        }\r\n\r\n        if (options.initialstate === 'preview') {\r\n          this.showPreview();\r\n        } else if (options.initialstate === 'fullscreen' && options.fullscreen.enable) {\r\n          this.setFullscreen(true);\r\n        }\r\n\r\n      } else {\r\n        this.$editor.show();\r\n      }\r\n\r\n      if (options.autofocus) {\r\n        this.$textarea.focus();\r\n        this.$editor.addClass('active');\r\n      }\r\n\r\n      if (options.fullscreen.enable && options.fullscreen !== false) {\r\n        this.$editor.append('<div class=\"md-fullscreen-controls\">'\r\n                        + '<a href=\"#\" class=\"exit-fullscreen\" title=\"Exit fullscreen\"><span class=\"' + this.__getIcon(options.fullscreen.icons.fullscreenOff) + '\">'\r\n                        + '</span></a>'\r\n                        + '</div>');\r\n        this.$editor.on('click', '.exit-fullscreen', function(e) {\r\n          e.preventDefault();\r\n          instance.setFullscreen(false);\r\n        });\r\n      }\r\n\r\n      // hide hidden buttons from options\r\n      this.hideButtons(options.hiddenButtons);\r\n\r\n      // disable disabled buttons from options\r\n      this.disableButtons(options.disabledButtons);\r\n\r\n      // Trigger the onShow hook\r\n      options.onShow(this);\r\n\r\n      return this;\r\n    }\r\n\r\n  , parseContent: function(val) {\r\n      var content;\r\n\r\n      // parse with supported markdown parser\r\n      var val = val || this.$textarea.val();\r\n\r\n      if (this.$options.parser) {\r\n        content = this.$options.parser(val);\r\n      } else if (typeof markdown == 'object') {\r\n        content = markdown.toHTML(val);\r\n      } else if (typeof marked == 'function') {\r\n        content = marked(val);\r\n      } else {\r\n        content = val;\r\n      }\r\n\r\n      return content;\r\n    }\r\n\r\n  , showPreview: function() {\r\n      var options = this.$options,\r\n          container = this.$textarea,\r\n          afterContainer = container.next(),\r\n          replacementContainer = $('<div/>',{'class':'md-preview','data-provider':'markdown-preview'}),\r\n          content,\r\n          callbackContent;\r\n\r\n      if (this.$isPreview == true) {\r\n        // Avoid sequenced element creation on missused scenario\r\n        // @see https://github.com/toopay/bootstrap-markdown/issues/170\r\n        return this;\r\n      }\r\n      \r\n      // Give flag that tell the editor enter preview mode\r\n      this.$isPreview = true;\r\n      // Disable all buttons\r\n      this.disableButtons('all').enableButtons('cmdPreview');\r\n\r\n      // Try to get the content from callback\r\n      callbackContent = options.onPreview(this);\r\n      // Set the content based from the callback content if string otherwise parse value from textarea\r\n      content = typeof callbackContent == 'string' ? callbackContent : this.parseContent();\r\n\r\n      // Build preview element\r\n      replacementContainer.html(content);\r\n\r\n      if (afterContainer && afterContainer.attr('class') == 'md-footer') {\r\n        // If there is footer element, insert the preview container before it\r\n        replacementContainer.insertBefore(afterContainer);\r\n      } else {\r\n        // Otherwise, just append it after textarea\r\n        container.parent().append(replacementContainer);\r\n      }\r\n\r\n      // Set the preview element dimensions\r\n      replacementContainer.css({\r\n        width: container.outerWidth() + 'px',\r\n        height: container.outerHeight() + 'px'\r\n      });\r\n\r\n      if (this.$options.resize) {\r\n        replacementContainer.css('resize',this.$options.resize);\r\n      }\r\n\r\n      // Hide the last-active textarea\r\n      container.hide();\r\n\r\n      // Attach the editor instances\r\n      replacementContainer.data('markdown',this);\r\n\r\n      if (this.$element.is(':disabled') || this.$element.is('[readonly]')) {\r\n        this.$editor.addClass('md-editor-disabled');\r\n        this.disableButtons('all');\r\n      }\r\n\r\n      return this;\r\n    }\r\n\r\n  , hidePreview: function() {\r\n      // Give flag that tell the editor quit preview mode\r\n      this.$isPreview = false;\r\n\r\n      // Obtain the preview container\r\n      var container = this.$editor.find('div[data-provider=\"markdown-preview\"]');\r\n\r\n      // Remove the preview container\r\n      container.remove();\r\n\r\n      // Enable all buttons\r\n      this.enableButtons('all');\r\n      // Disable configured disabled buttons\r\n      this.disableButtons(this.$options.disabledButtons);\r\n\r\n      // Back to the editor\r\n      this.$textarea.show();\r\n      this.__setListener();\r\n\r\n      return this;\r\n    }\r\n\r\n  , isDirty: function() {\r\n      return this.$oldContent != this.getContent();\r\n    }\r\n\r\n  , getContent: function() {\r\n      return this.$textarea.val();\r\n    }\r\n\r\n  , setContent: function(content) {\r\n      this.$textarea.val(content);\r\n\r\n      return this;\r\n    }\r\n\r\n  , findSelection: function(chunk) {\r\n    var content = this.getContent(), startChunkPosition;\r\n\r\n    if (startChunkPosition = content.indexOf(chunk), startChunkPosition >= 0 && chunk.length > 0) {\r\n      var oldSelection = this.getSelection(), selection;\r\n\r\n      this.setSelection(startChunkPosition,startChunkPosition+chunk.length);\r\n      selection = this.getSelection();\r\n\r\n      this.setSelection(oldSelection.start,oldSelection.end);\r\n\r\n      return selection;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  , getSelection: function() {\r\n\r\n      var e = this.$textarea[0];\r\n\r\n      return (\r\n\r\n          ('selectionStart' in e && function() {\r\n              var l = e.selectionEnd - e.selectionStart;\r\n              return { start: e.selectionStart, end: e.selectionEnd, length: l, text: e.value.substr(e.selectionStart, l) };\r\n          }) ||\r\n\r\n          /* browser not supported */\r\n          function() {\r\n            return null;\r\n          }\r\n\r\n      )();\r\n\r\n    }\r\n\r\n  , setSelection: function(start,end) {\r\n\r\n      var e = this.$textarea[0];\r\n\r\n      return (\r\n\r\n          ('selectionStart' in e && function() {\r\n              e.selectionStart = start;\r\n              e.selectionEnd = end;\r\n              return;\r\n          }) ||\r\n\r\n          /* browser not supported */\r\n          function() {\r\n            return null;\r\n          }\r\n\r\n      )();\r\n\r\n    }\r\n\r\n  , replaceSelection: function(text) {\r\n\r\n      var e = this.$textarea[0];\r\n\r\n      return (\r\n\r\n          ('selectionStart' in e && function() {\r\n              e.value = e.value.substr(0, e.selectionStart) + text + e.value.substr(e.selectionEnd, e.value.length);\r\n              // Set cursor to the last replacement end\r\n              e.selectionStart = e.value.length;\r\n              return this;\r\n          }) ||\r\n\r\n          /* browser not supported */\r\n          function() {\r\n              e.value += text;\r\n              return jQuery(e);\r\n          }\r\n\r\n      )();\r\n    }\r\n\r\n  , getNextTab: function() {\r\n      // Shift the nextTab\r\n      if (this.$nextTab.length === 0) {\r\n        return null;\r\n      } else {\r\n        var nextTab, tab = this.$nextTab.shift();\r\n\r\n        if (typeof tab == 'function') {\r\n          nextTab = tab();\r\n        } else if (typeof tab == 'object' && tab.length > 0) {\r\n          nextTab = tab;\r\n        }\r\n\r\n        return nextTab;\r\n      }\r\n    }\r\n\r\n  , setNextTab: function(start,end) {\r\n      // Push new selection into nextTab collections\r\n      if (typeof start == 'string') {\r\n        var that = this;\r\n        this.$nextTab.push(function(){\r\n          return that.findSelection(start);\r\n        });\r\n      } else if (typeof start == 'number' && typeof end == 'number') {\r\n        var oldSelection = this.getSelection();\r\n\r\n        this.setSelection(start,end);\r\n        this.$nextTab.push(this.getSelection());\r\n\r\n        this.setSelection(oldSelection.start,oldSelection.end);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n  , __parseButtonNameParam: function (names) {\r\n      return typeof names == 'string' ?\r\n                      names.split(' ') :\r\n                      names;\r\n\r\n    }\r\n\r\n  , enableButtons: function(name) {\r\n      var buttons = this.__parseButtonNameParam(name),\r\n        that = this;\r\n\r\n      $.each(buttons, function(i, v) {\r\n        that.__alterButtons(buttons[i], function (el) {\r\n          el.removeAttr('disabled');\r\n        });\r\n      });\r\n\r\n      return this;\r\n    }\r\n\r\n  , disableButtons: function(name) {\r\n      var buttons = this.__parseButtonNameParam(name),\r\n        that = this;\r\n\r\n      $.each(buttons, function(i, v) {\r\n        that.__alterButtons(buttons[i], function (el) {\r\n          el.attr('disabled','disabled');\r\n        });\r\n      });\r\n\r\n      return this;\r\n    }\r\n\r\n  , hideButtons: function(name) {\r\n      var buttons = this.__parseButtonNameParam(name),\r\n        that = this;\r\n\r\n      $.each(buttons, function(i, v) {\r\n        that.__alterButtons(buttons[i], function (el) {\r\n          el.addClass('hidden');\r\n        });\r\n      });\r\n\r\n      return this;\r\n    }\r\n\r\n  , showButtons: function(name) {\r\n      var buttons = this.__parseButtonNameParam(name),\r\n        that = this;\r\n\r\n      $.each(buttons, function(i, v) {\r\n        that.__alterButtons(buttons[i], function (el) {\r\n          el.removeClass('hidden');\r\n        });\r\n      });\r\n\r\n      return this;\r\n    }\r\n\r\n  , eventSupported: function(eventName) {\r\n      var isSupported = eventName in this.$element;\r\n      if (!isSupported) {\r\n        this.$element.setAttribute(eventName, 'return;');\r\n        isSupported = typeof this.$element[eventName] === 'function';\r\n      }\r\n      return isSupported;\r\n    }\r\n\r\n  , keyup: function (e) {\r\n      var blocked = false;\r\n      switch(e.keyCode) {\r\n        case 40: // down arrow\r\n        case 38: // up arrow\r\n        case 16: // shift\r\n        case 17: // ctrl\r\n        case 18: // alt\r\n          break;\r\n\r\n        case 9: // tab\r\n          var nextTab;\r\n          if (nextTab = this.getNextTab(),nextTab !== null) {\r\n            // Get the nextTab if exists\r\n            var that = this;\r\n            setTimeout(function(){\r\n              that.setSelection(nextTab.start,nextTab.end);\r\n            },500);\r\n\r\n            blocked = true;\r\n          } else {\r\n            // The next tab memory contains nothing...\r\n            // check the cursor position to determine tab action\r\n            var cursor = this.getSelection();\r\n\r\n            if (cursor.start == cursor.end && cursor.end == this.getContent().length) {\r\n              // The cursor already reach the end of the content\r\n              blocked = false;\r\n            } else {\r\n              // Put the cursor to the end\r\n              this.setSelection(this.getContent().length,this.getContent().length);\r\n\r\n              blocked = true;\r\n            }\r\n          }\r\n\r\n          break;\r\n\r\n        case 13: // enter\r\n          blocked = false;\r\n          break;\r\n        case 27: // escape\r\n          if (this.$isFullscreen) this.setFullscreen(false);\r\n          blocked = false;\r\n          break;\r\n\r\n        default:\r\n          blocked = false;\r\n      }\r\n\r\n      if (blocked) {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n      }\r\n\r\n      this.$options.onChange(this);\r\n    }\r\n\r\n  , change: function(e) {\r\n      this.$options.onChange(this);\r\n      return this;\r\n    }\r\n  , select: function (e) {\r\n      this.$options.onSelect(this);\r\n      return this;\r\n    }\r\n  , focus: function (e) {\r\n      var options = this.$options,\r\n          isHideable = options.hideable,\r\n          editor = this.$editor;\r\n\r\n      editor.addClass('active');\r\n\r\n      // Blur other markdown(s)\r\n      $(document).find('.md-editor').each(function(){\r\n        if ($(this).attr('id') !== editor.attr('id')) {\r\n          var attachedMarkdown;\r\n\r\n          if (attachedMarkdown = $(this).find('textarea').data('markdown'),\r\n              attachedMarkdown === null) {\r\n              attachedMarkdown = $(this).find('div[data-provider=\"markdown-preview\"]').data('markdown');\r\n          }\r\n\r\n          if (attachedMarkdown) {\r\n            attachedMarkdown.blur();\r\n          }\r\n        }\r\n      });\r\n\r\n      // Trigger the onFocus hook\r\n      options.onFocus(this);\r\n\r\n      return this;\r\n    }\r\n\r\n  , blur: function (e) {\r\n      var options = this.$options,\r\n          isHideable = options.hideable,\r\n          editor = this.$editor,\r\n          editable = this.$editable;\r\n\r\n      if (editor.hasClass('active') || this.$element.parent().length === 0) {\r\n        editor.removeClass('active');\r\n\r\n        if (isHideable) {\r\n          // Check for editable elements\r\n          if (editable.el !== null) {\r\n            // Build the original element\r\n            var oldElement = $('<'+editable.type+'/>'),\r\n                content = this.getContent(),\r\n                currentContent = this.parseContent(content);\r\n\r\n            $(editable.attrKeys).each(function(k,v) {\r\n              oldElement.attr(editable.attrKeys[k],editable.attrValues[k]);\r\n            });\r\n\r\n            // Get the editor content\r\n            oldElement.html(currentContent);\r\n\r\n            editor.replaceWith(oldElement);\r\n          } else {\r\n            editor.hide();\r\n          }\r\n        }\r\n\r\n        // Trigger the onBlur hook\r\n        options.onBlur(this);\r\n      }\r\n\r\n      return this;\r\n    }\r\n\r\n  };\r\n\r\n /* MARKDOWN PLUGIN DEFINITION\r\n  * ========================== */\r\n\r\n  var old = $.fn.markdown;\r\n\r\n  $.fn.markdown = function (option) {\r\n    return this.each(function () {\r\n      var $this = $(this)\r\n        , data = $this.data('markdown')\r\n        , options = typeof option == 'object' && option;\r\n      if (!data) $this.data('markdown', (data = new Markdown(this, options)))\r\n    })\r\n  };\r\n\r\n  $.fn.markdown.messages = {};\r\n\r\n  $.fn.markdown.defaults = {\r\n    /* Editor Properties */\r\n    autofocus: false,\r\n    hideable: false,\r\n    savable: false,\r\n    width: 'inherit',\r\n    height: 'inherit',\r\n    resize: 'none',\r\n    iconlibrary: 'glyph',\r\n    language: 'en',\r\n    initialstate: 'editor',\r\n    parser: null,\r\n\r\n    /* Buttons Properties */\r\n    buttons: [\r\n      [{\r\n        name: 'groupFont',\r\n        data: [{\r\n          name: 'cmdBold',\r\n          hotkey: 'Ctrl+B',\r\n          title: 'Bold',\r\n          icon: { glyph: 'glyphicon glyphicon-bold', fa: 'fa fa-bold', 'fa-3': 'icon-bold' },\r\n          callback: function(e){\r\n            // Give/remove ** surround the selection\r\n            var chunk, cursor, selected = e.getSelection(), content = e.getContent();\r\n\r\n            if (selected.length === 0) {\r\n              // Give extra word\r\n              chunk = e.__localize('strong text');\r\n            } else {\r\n              chunk = selected.text;\r\n            }\r\n\r\n            // transform selection and set the cursor into chunked text\r\n            if (content.substr(selected.start-2,2) === '**'\r\n                && content.substr(selected.end,2) === '**' ) {\r\n              e.setSelection(selected.start-2,selected.end+2);\r\n              e.replaceSelection(chunk);\r\n              cursor = selected.start-2;\r\n            } else {\r\n              e.replaceSelection('**'+chunk+'**');\r\n              cursor = selected.start+2;\r\n            }\r\n\r\n            // Set the cursor\r\n            e.setSelection(cursor,cursor+chunk.length);\r\n          }\r\n        },{\r\n          name: 'cmdItalic',\r\n          title: 'Italic',\r\n          hotkey: 'Ctrl+I',\r\n          icon: { glyph: 'glyphicon glyphicon-italic', fa: 'fa fa-italic', 'fa-3': 'icon-italic' },\r\n          callback: function(e){\r\n            // Give/remove * surround the selection\r\n            var chunk, cursor, selected = e.getSelection(), content = e.getContent();\r\n\r\n            if (selected.length === 0) {\r\n              // Give extra word\r\n              chunk = e.__localize('emphasized text');\r\n            } else {\r\n              chunk = selected.text;\r\n            }\r\n\r\n            // transform selection and set the cursor into chunked text\r\n            if (content.substr(selected.start-1,1) === '_'\r\n                && content.substr(selected.end,1) === '_' ) {\r\n              e.setSelection(selected.start-1,selected.end+1);\r\n              e.replaceSelection(chunk);\r\n              cursor = selected.start-1;\r\n            } else {\r\n              e.replaceSelection('_'+chunk+'_');\r\n              cursor = selected.start+1;\r\n            }\r\n\r\n            // Set the cursor\r\n            e.setSelection(cursor,cursor+chunk.length);\r\n          }\r\n        },{\r\n          name: 'cmdHeading',\r\n          title: 'Heading',\r\n          hotkey: 'Ctrl+H',\r\n          icon: { glyph: 'glyphicon glyphicon-header', fa: 'fa fa-header', 'fa-3': 'icon-font' },\r\n          callback: function(e){\r\n            // Append/remove ### surround the selection\r\n            var chunk, cursor, selected = e.getSelection(), content = e.getContent(), pointer, prevChar;\r\n\r\n            if (selected.length === 0) {\r\n              // Give extra word\r\n              chunk = e.__localize('heading text');\r\n            } else {\r\n              chunk = selected.text + '\\n';\r\n            }\r\n\r\n            // transform selection and set the cursor into chunked text\r\n            if ((pointer = 4, content.substr(selected.start-pointer,pointer) === '### ')\r\n                || (pointer = 3, content.substr(selected.start-pointer,pointer) === '###')) {\r\n              e.setSelection(selected.start-pointer,selected.end);\r\n              e.replaceSelection(chunk);\r\n              cursor = selected.start-pointer;\r\n            } else if (selected.start > 0 && (prevChar = content.substr(selected.start-1,1), !!prevChar && prevChar != '\\n')) {\r\n              e.replaceSelection('\\n\\n### '+chunk);\r\n              cursor = selected.start+6;\r\n            } else {\r\n              // Empty string before element\r\n              e.replaceSelection('### '+chunk);\r\n              cursor = selected.start+4;\r\n            }\r\n\r\n            // Set the cursor\r\n            e.setSelection(cursor,cursor+chunk.length);\r\n          }\r\n        }]\r\n      },{\r\n        name: 'groupLink',\r\n        data: [{\r\n          name: 'cmdUrl',\r\n          title: 'URL/Link',\r\n          hotkey: 'Ctrl+L',\r\n          icon: { glyph: 'glyphicon glyphicon-link', fa: 'fa fa-link', 'fa-3': 'icon-link' },\r\n          callback: function(e){\r\n            // Give [] surround the selection and prepend the link\r\n            var chunk, cursor, selected = e.getSelection(), content = e.getContent(), link;\r\n\r\n            if (selected.length === 0) {\r\n              // Give extra word\r\n              chunk = e.__localize('enter link description here');\r\n            } else {\r\n              chunk = selected.text;\r\n            }\r\n\r\n            link = prompt(e.__localize('Insert Hyperlink'),'http://');\r\n\r\n            var urlRegex = new RegExp('^((http|https)://|(mailto:)|(//))[a-z0-9]', 'i');\r\n            if (link !== null && link !== '' && link !== 'http://' && urlRegex.test(link)) {\r\n              var sanitizedLink = $('<div>'+link+'</div>').text();\r\n\r\n              // transform selection and set the cursor into chunked text\r\n              e.replaceSelection('['+chunk+']('+sanitizedLink+')');\r\n              cursor = selected.start+1;\r\n\r\n              // Set the cursor\r\n              e.setSelection(cursor,cursor+chunk.length);\r\n            }\r\n          }\r\n        },{\r\n          name: 'cmdImage',\r\n          title: 'Image',\r\n          hotkey: 'Ctrl+G',\r\n          icon: { glyph: 'glyphicon glyphicon-picture', fa: 'fa fa-picture-o', 'fa-3': 'icon-picture' },\r\n          callback: function(e){\r\n            // Give ![] surround the selection and prepend the image link\r\n            var chunk, cursor, selected = e.getSelection(), content = e.getContent(), link;\r\n\r\n            if (selected.length === 0) {\r\n              // Give extra word\r\n              chunk = e.__localize('enter image description here');\r\n            } else {\r\n              chunk = selected.text;\r\n            }\r\n\r\n            link = prompt(e.__localize('Insert Image Hyperlink'),'http://');\r\n\r\n            var urlRegex = new RegExp('^((http|https)://|(//))[a-z0-9]', 'i');\r\n            if (link !== null && link !== '' && link !== 'http://' && urlRegex.test(link)) {\r\n              var sanitizedLink = $('<div>'+link+'</div>').text();\r\n\r\n              // transform selection and set the cursor into chunked text\r\n              e.replaceSelection('!['+chunk+']('+sanitizedLink+' \"'+e.__localize('enter image title here')+'\")');\r\n              cursor = selected.start+2;\r\n\r\n              // Set the next tab\r\n              e.setNextTab(e.__localize('enter image title here'));\r\n\r\n              // Set the cursor\r\n              e.setSelection(cursor,cursor+chunk.length);\r\n            }\r\n          }\r\n        }]\r\n      },{\r\n        name: 'groupMisc',\r\n        data: [{\r\n          name: 'cmdList',\r\n          hotkey: 'Ctrl+U',\r\n          title: 'Unordered List',\r\n          icon: { glyph: 'glyphicon glyphicon-list', fa: 'fa fa-list', 'fa-3': 'icon-list-ul' },\r\n          callback: function(e){\r\n            // Prepend/Give - surround the selection\r\n            var chunk, cursor, selected = e.getSelection(), content = e.getContent();\r\n\r\n            // transform selection and set the cursor into chunked text\r\n            if (selected.length === 0) {\r\n              // Give extra word\r\n              chunk = e.__localize('list text here');\r\n\r\n              e.replaceSelection('- '+chunk);\r\n              // Set the cursor\r\n              cursor = selected.start+2;\r\n            } else {\r\n              if (selected.text.indexOf('\\n') < 0) {\r\n                chunk = selected.text;\r\n\r\n                e.replaceSelection('- '+chunk);\r\n\r\n                // Set the cursor\r\n                cursor = selected.start+2;\r\n              } else {\r\n                var list = [];\r\n\r\n                list = selected.text.split('\\n');\r\n                chunk = list[0];\r\n\r\n                $.each(list,function(k,v) {\r\n                  list[k] = '- '+v;\r\n                });\r\n\r\n                e.replaceSelection('\\n\\n'+list.join('\\n'));\r\n\r\n                // Set the cursor\r\n                cursor = selected.start+4;\r\n              }\r\n            }\r\n\r\n            // Set the cursor\r\n            e.setSelection(cursor,cursor+chunk.length);\r\n          }\r\n        },\r\n        {\r\n          name: 'cmdListO',\r\n          hotkey: 'Ctrl+O',\r\n          title: 'Ordered List',\r\n          icon: { glyph: 'glyphicon glyphicon-th-list', fa: 'fa fa-list-ol', 'fa-3': 'icon-list-ol' },\r\n          callback: function(e) {\r\n\r\n            // Prepend/Give - surround the selection\r\n            var chunk, cursor, selected = e.getSelection(), content = e.getContent();\r\n\r\n            // transform selection and set the cursor into chunked text\r\n            if (selected.length === 0) {\r\n              // Give extra word\r\n              chunk = e.__localize('list text here');\r\n              e.replaceSelection('1. '+chunk);\r\n              // Set the cursor\r\n              cursor = selected.start+3;\r\n            } else {\r\n              if (selected.text.indexOf('\\n') < 0) {\r\n                chunk = selected.text;\r\n\r\n                e.replaceSelection('1. '+chunk);\r\n\r\n                // Set the cursor\r\n                cursor = selected.start+3;\r\n              } else {\r\n                var list = [];\r\n\r\n                list = selected.text.split('\\n');\r\n                chunk = list[0];\r\n\r\n                $.each(list,function(k,v) {\r\n                  list[k] = '1. '+v;\r\n                });\r\n\r\n                e.replaceSelection('\\n\\n'+list.join('\\n'));\r\n\r\n                // Set the cursor\r\n                cursor = selected.start+5;\r\n              }\r\n            }\r\n\r\n            // Set the cursor\r\n            e.setSelection(cursor,cursor+chunk.length);\r\n          }\r\n        },\r\n        {\r\n          name: 'cmdCode',\r\n          hotkey: 'Ctrl+K',\r\n          title: 'Code',\r\n          icon: { glyph: 'glyphicon glyphicon-asterisk', fa: 'fa fa-code', 'fa-3': 'icon-code' },\r\n          callback: function(e) {\r\n            // Give/remove ** surround the selection\r\n            var chunk, cursor, selected = e.getSelection(), content = e.getContent();\r\n\r\n            if (selected.length === 0) {\r\n              // Give extra word\r\n              chunk = e.__localize('code text here');\r\n            } else {\r\n              chunk = selected.text;\r\n            }\r\n\r\n            // transform selection and set the cursor into chunked text\r\n            if (content.substr(selected.start-4,4) === '```\\n'\r\n                && content.substr(selected.end,4) === '\\n```') {\r\n              e.setSelection(selected.start-4, selected.end+4);\r\n              e.replaceSelection(chunk);\r\n              cursor = selected.start-4;\r\n            } else if (content.substr(selected.start-1,1) === '`'\r\n                && content.substr(selected.end,1) === '`') {\r\n              e.setSelection(selected.start-1,selected.end+1);\r\n              e.replaceSelection(chunk);\r\n              cursor = selected.start-1;\r\n            } else if (content.indexOf('\\n') > -1) {\r\n              e.replaceSelection('```\\n'+chunk+'\\n```');\r\n              cursor = selected.start+4;\r\n            } else {\r\n              e.replaceSelection('`'+chunk+'`');\r\n              cursor = selected.start+1;\r\n            }\r\n\r\n            // Set the cursor\r\n            e.setSelection(cursor,cursor+chunk.length);\r\n          }\r\n        },\r\n        {\r\n          name: 'cmdQuote',\r\n          hotkey: 'Ctrl+Q',\r\n          title: 'Quote',\r\n          icon: { glyph: 'glyphicon glyphicon-comment', fa: 'fa fa-quote-left', 'fa-3': 'icon-quote-left' },\r\n          callback: function(e) {\r\n            // Prepend/Give - surround the selection\r\n            var chunk, cursor, selected = e.getSelection(), content = e.getContent();\r\n\r\n            // transform selection and set the cursor into chunked text\r\n            if (selected.length === 0) {\r\n              // Give extra word\r\n              chunk = e.__localize('quote here');\r\n\r\n              e.replaceSelection('> '+chunk);\r\n\r\n              // Set the cursor\r\n              cursor = selected.start+2;\r\n            } else {\r\n              if (selected.text.indexOf('\\n') < 0) {\r\n                chunk = selected.text;\r\n\r\n                e.replaceSelection('> '+chunk);\r\n\r\n                // Set the cursor\r\n                cursor = selected.start+2;\r\n              } else {\r\n                var list = [];\r\n\r\n                list = selected.text.split('\\n');\r\n                chunk = list[0];\r\n\r\n                $.each(list,function(k,v) {\r\n                  list[k] = '> '+v;\r\n                });\r\n\r\n                e.replaceSelection('\\n\\n'+list.join('\\n'));\r\n\r\n                // Set the cursor\r\n                cursor = selected.start+4;\r\n              }\r\n            }\r\n\r\n            // Set the cursor\r\n            e.setSelection(cursor,cursor+chunk.length);\r\n          }\r\n        }]\r\n      },{\r\n        name: 'groupUtil',\r\n        data: [{\r\n          name: 'cmdPreview',\r\n          toggle: true,\r\n          hotkey: 'Ctrl+P',\r\n          title: 'Preview',\r\n          btnText: 'Preview',\r\n          btnClass: 'btn btn-primary btn-sm',\r\n          icon: { glyph: 'glyphicon glyphicon-search', fa: 'fa fa-search', 'fa-3': 'icon-search' },\r\n          callback: function(e){\r\n            // Check the preview mode and toggle based on this flag\r\n            var isPreview = e.$isPreview,content;\r\n\r\n            if (isPreview === false) {\r\n              // Give flag that tell the editor enter preview mode\r\n              e.showPreview();\r\n            } else {\r\n              e.hidePreview();\r\n            }\r\n          }\r\n        }]\r\n      }]\r\n    ],\r\n    additionalButtons:[], // Place to hook more buttons by code\r\n    reorderButtonGroups:[],\r\n    hiddenButtons:[], // Default hidden buttons\r\n    disabledButtons:[], // Default disabled buttons\r\n    footer: '',\r\n    fullscreen: {\r\n      enable: true,\r\n      icons: {\r\n        fullscreenOn: {\r\n          fa: 'fa fa-expand',\r\n          glyph: 'glyphicon glyphicon-fullscreen',\r\n          'fa-3': 'icon-resize-full'\r\n        },\r\n        fullscreenOff: {\r\n          fa: 'fa fa-compress',\r\n          glyph: 'glyphicon glyphicon-fullscreen',\r\n          'fa-3': 'icon-resize-small'\r\n        }\r\n      }\r\n    },\r\n\r\n    /* Events hook */\r\n    onShow: function (e) {},\r\n    onPreview: function (e) {},\r\n    onSave: function (e) {},\r\n    onBlur: function (e) {},\r\n    onFocus: function (e) {},\r\n    onChange: function(e) {},\r\n    onFullscreen: function(e) {},\r\n    onSelect: function (e) {}\r\n  };\r\n\r\n  $.fn.markdown.Constructor = Markdown;\r\n\r\n\r\n /* MARKDOWN NO CONFLICT\r\n  * ==================== */\r\n\r\n  $.fn.markdown.noConflict = function () {\r\n    $.fn.markdown = old;\r\n    return this;\r\n  };\r\n\r\n  /* MARKDOWN GLOBAL FUNCTION & DATA-API\r\n  * ==================================== */\r\n  var initMarkdown = function(el) {\r\n    var $this = el;\r\n\r\n    if ($this.data('markdown')) {\r\n      $this.data('markdown').showEditor();\r\n      return;\r\n    }\r\n\r\n    $this.markdown()\r\n  };\r\n\r\n  var blurNonFocused = function(e) {\r\n    var $activeElement = $(document.activeElement);\r\n\r\n    // Blur event\r\n    $(document).find('.md-editor').each(function(){\r\n      var $this            = $(this),\r\n          focused          = $activeElement.closest('.md-editor')[0] === this,\r\n          attachedMarkdown = $this.find('textarea').data('markdown') ||\r\n                             $this.find('div[data-provider=\"markdown-preview\"]').data('markdown');\r\n\r\n      if (attachedMarkdown && !focused) {\r\n        attachedMarkdown.blur();\r\n      }\r\n    })\r\n  };\r\n\r\n  $(document)\r\n    .on('click.markdown.data-api', '[data-provide=\"markdown-editable\"]', function (e) {\r\n      initMarkdown($(this));\r\n      e.preventDefault();\r\n    })\r\n    .on('click focusin', function (e) {\r\n      blurNonFocused(e);\r\n    })\r\n    .ready(function(){\r\n      $('textarea[data-provide=\"markdown\"]').each(function(){\r\n        initMarkdown($(this));\r\n      })\r\n    });\r\n\r\n}));\r\n"],"sourceRoot":"/source/"}